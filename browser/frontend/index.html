<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compressed Genome Viewer - D3</title>
    
    <!-- D3.js (local copy) -->
    <script src="d3.v7.min.js"></script>

    <!-- Mol* styles (bundled with Vite) -->
    <!-- Note: molstar.css is imported in molstar-plugin.ts -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .header {
            display: none; /* Hidden to maximize screen space */
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px 30px;
            border-bottom: 1px solid #0f3460;
        }
        
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #e94560;
            margin-bottom: 5px;
            letter-spacing: -0.5px;
        }
        
        .header p {
            font-size: 0.9rem;
            color: #888;
        }
        
        .controls {
            background: #16213e;
            padding: 15px 30px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #0f3460;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Panel toggle buttons (Cursor-style) */
        .panel-toggles {
            display: flex;
            gap: 2px;
            margin-left: auto;
            background: #1a1a2e;
            border-radius: 6px;
            padding: 3px;
        }

        .panel-btn {
            width: 50px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .panel-btn:hover {
            background: #2a2a3e;
            color: #aaa;
        }

        .panel-btn.active {
            color: #e94560;
        }

        .panel-btn.active:hover {
            background: #2a2a3e;
            color: #e94560;
        }

        .panel-btn svg {
            width: 50px;
            height: 40px;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #eee;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #0f3460;
            color: #e94560;
        }

        .autocomplete-item .gene-info {
            font-size: 0.7rem;
            color: #888;
            margin-left: 8px;
        }

        label {
            font-size: 0.85rem;
            color: #aaa;
            font-weight: 500;
        }
        
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            font-size: 0.85rem;
            background: #1a1a2e;
            color: #eee;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #e94560;
        }
        
        button {
            background: #e94560;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #ff6b6b;
            transform: translateY(-1px);
        }
        
        button.secondary {
            background: #0f3460;
        }
        
        button.secondary:hover {
            background: #16213e;
        }

        /* Crosshair toggle active state */
        .zoom-controls button.crosshair-active {
            background: #e94560;
            color: #fff;
        }

        /* Residue highlight overlay (for 3D structure hover) */
        .residue-highlight-rect {
            fill: rgba(255, 255, 0, 0.25);
            stroke: rgba(255, 200, 0, 0.8);
            stroke-width: 2;
        }

        /* AA toggle less bold */
        .zoom-controls #axis-toggle {
            font-weight: 500;
        }
        
        .main-container {
            display: flex;
            height: calc(100vh - 130px - 36px);  /* Subtract header, controls, and status bar */
            margin-bottom: 36px;  /* Make room for status bar */
        }
        
        .track-panel {
            width: 300px;
            min-width: 200px;
            max-width: 600px;
            background: #16213e;
            border-right: 1px solid #0f3460;
            overflow-y: auto;
            padding: 15px;
            max-height: calc(100vh - 180px - 36px);  /* Subtract header, controls, and status bar */
            flex-shrink: 0;
        }
        
        .track-panel h3 {
            font-size: 0.9rem;
            color: #e94560;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #0f3460;
        }
        
        .track-category {
            margin-bottom: 15px;
        }
        
        .track-category-label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .track-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .track-chip {
            padding: 5px 10px;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .track-chip:hover {
            border-color: #e94560;
        }
        
        .track-chip.selected {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        /* Track tree */
        .track-tree-node {
            margin-bottom: 6px;
        }

        .track-tree-node .node-header {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
            color: #d0d4ff;
            font-size: 0.85rem;
        }

        .track-tree-node .node-header .toggle {
            width: 14px;
            text-align: center;
            font-weight: bold;
            color: #aaa;
        }

        .track-tree-node .node-header .expand-all {
            margin-left: auto;
            font-size: 0.75rem;
            color: #888;
            cursor: pointer;
            padding: 2px 6px;
            border: 1px solid #2b3555;
            border-radius: 6px;
            background: #1a1f3d;
        }

        .track-tree-node .node-header .expand-all:hover {
            border-color: #e94560;
            color: #e94560;
        }

        .track-tree-children {
            margin-left: 16px;
            border-left: 1px dashed #2b3555;
            padding-left: 8px;
        }

        .track-tree-leaf {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #eee;
            font-size: 0.85rem;
            margin: 4px 0;
        }

        .track-tree-leaf input {
            cursor: pointer;
        }

        /* ClinVar filter styles */
        .clinvar-filter-container {
            background: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 6px;
            padding: 8px;
            margin: 8px 0;
        }

        .clinvar-filter-header {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .clinvar-filter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .clinvar-filter-option {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: #16213e;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .clinvar-filter-option:hover {
            background: #1e2d4d;
        }

        .clinvar-filter-option input {
            cursor: pointer;
            width: 12px;
            height: 12px;
        }

        .clinvar-filter-option span {
            color: #ddd;
        }
        
        .visualization-panel {
            flex: 1;
            padding: 20px;
            overflow: auto;
            background: #2A2B2E; /* light gray background for track display */
        }
        
        #chart-container {
            background: #E4E0DD; /* lighter gray for the chart surface */
            border-radius: 8px;
            padding: 20px;
            min-height: 400px;
            position: relative;
        }
        
        .track-row {
            margin-bottom: 10px;
        }
        
        .track-label {
            font-size: 0.75rem;
            fill: #333333; /* mid-dark for readability on light chart */
        }
        
        .axis text {
            font-size: 0.7rem;
            fill: #333333; /* mid-dark to avoid looking washed out */
        }
        
        .axis line, .axis path {
            stroke: #555555; /* soften grid/axis lines */
        }
        
        .tooltip {
            position: absolute;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid #e94560;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .tooltip-title {
            font-weight: 600;
            color: #e94560;
            margin-bottom: 6px;
        }
        
        .tooltip-row {
            color: #ccc;
            margin: 3px 0;
        }
        
        .tooltip-value {
            color: #fff;
            font-weight: 500;
        }
        
        .colorbar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 10px;
        }
        
        .colorbar-label {
            font-size: 0.7rem;
            fill: #888;
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #0f3460;
            padding: 8px 20px;
            font-size: 0.8rem;
            color: #888;
            display: flex;
            justify-content: space-between;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: #888;
        }
        
        .loading::after {
            content: '';
            width: 30px;
            height: 30px;
            border: 3px solid #0f3460;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 15px;
        }
        
        /* Zoom controls */
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .zoom-controls button {
            width: 32px;
            height: 32px;
            border: none;
            background: #0f3460;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .zoom-controls button:hover {
            background: #e94560;
        }
        
        /* Gene display banner - hidden to maximize screen space */
        .gene-display-banner {
            display: none;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            padding: 12px 30px;
            border-bottom: 1px solid #0f3460;
            /* display: flex; - uncomment to show banner */
            gap: 15px;
            align-items: center;
        }
        
        .gene-display-banner .label {
            font-size: 0.85rem;
            color: #888;
            font-weight: 600;
        }
        
        .gene-display-banner .gene-list {
            font-size: 0.9rem;
            color: #e94560;
            font-weight: 500;
        }
        
        /* Brush selection styling */
        .brush .selection {
            fill: rgba(233, 69, 96, 0.2);
            stroke: #e94560;
            stroke-width: 2px;
        }
        
        /* Selected tracks list - draggable */
        .selected-tracks-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
        }
        
        .selected-tracks-section h4 {
            font-size: 0.85rem;
            color: #e94560;
            margin-bottom: 10px;
        }
        
        .selected-track-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: #0f3460;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s;
            user-select: none;
        }
        
        .selected-track-item:hover {
            background: #1a4a7a;
        }
        
        .selected-track-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .selected-track-item.drag-over {
            border-top: 2px solid #e94560;
            margin-top: -2px;
        }
        
        .selected-track-item .drag-handle {
            color: #666;
            margin-right: 10px;
            font-size: 1rem;
        }
        
        .selected-track-item .track-name {
            flex: 1;
            font-size: 0.8rem;
            color: #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .selected-track-item .remove-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1rem;
            line-height: 1;
        }
        
        .selected-track-item .remove-btn:hover {
            color: #e94560;
        }
        
        /* Panel toggle button */
        .panel-toggle {
            display: none !important; /* Hidden - using top bar buttons instead */
        }

        .panel-toggle:hover {
            background: #e94560;
            color: white;
            width: 28px;
        }

        .panel-toggle.collapsed {
            left: 0 !important;
            border-left: 1px solid #0f3460;
            border-right: none;
            border-radius: 6px 0 0 6px;
        }
        
        .track-panel {
            transition: width 0.3s ease, min-width 0.3s ease;
        }

        .track-panel.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            padding: 0;
            overflow: hidden;
            border-right: none;
        }

        .track-panel.collapsed + .resize-divider {
            display: none;
        }
        
        .main-container {
            position: relative;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Structure Panel Styles */
        .structure-panel {
            width: 400px;
            min-width: 300px;
            max-width: 800px;
            background: #2A2B2E;
            border-left: 1px solid #0f3460;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
            flex-shrink: 0;
            position: relative;  /* Positioning context for tooltip */
        }
        
        .structure-panel.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            padding: 0;
            overflow: hidden;
            border-left: none;
        }

        #structure-panel.collapsed ~ #right-divider {
            display: none;
        }
        
        .structure-panel-header {
            padding: 15px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .structure-panel-header h3 {
            font-size: 0.9rem;
            color: #e94560;
            margin: 0;
        }
        
        .structure-panel-header .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
        }
        
        .structure-panel-header .close-btn:hover {
            color: #e94560;
        }
        
        .structure-controls {
            border-bottom: 1px solid #0f3460;
            position: relative;
            transition: all 0.3s ease;
        }

        .structure-controls-content {
            padding: 8px 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .structure-controls select,
        .structure-controls button {
            padding: 6px 10px;
            font-size: 0.75rem;
        }
        
        .structure-viewer-container {
            flex: 1;
            min-height: 400px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        #molstar-viewer {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* =================================================================
         * ISSUE 1: Hide ALL Mol* default UI elements
         * ================================================================= */
        
        /* Hide control panels and sidebars */
        #molstar-viewer .msp-controls,
        #molstar-viewer .msp-sequence-wrapper,
        #molstar-viewer .msp-log-content,
        #molstar-viewer .msp-state-tree,
        #molstar-viewer .msp-left-panel-controls,
        #molstar-viewer .msp-layout-controls,
        #molstar-viewer .msp-transform-header,
        #molstar-viewer .msp-control-group-header,
        #molstar-viewer .msp-highlight-info,
        .msp-highlight-info,
        #molstar-viewer .msp-toast,
        #molstar-viewer .msp-notification {
            display: none !important;
        }
        
        /* =================================================================
         * Mol* viewport controls: Show only the reset button
         * We hide all buttons by default, then JS will show the reset button
         * by adding a .molstar-show-reset class to it after init.
         * ================================================================= */
        
        /* Hide ALL Mol* toolbar elements we don't need */
        #molstar-viewer .msp-highlight-info,
        #molstar-viewer .msp-select-mode-class,
        #molstar-viewer .msp-btn-row-group,
        #molstar-viewer .msp-semi-transparent-background {
            display: none !important;
        }
        
        /* Hide the selection mode controls - the top toolbar with Residue dropdown */
        #molstar-viewer [class*="msp-select"],
        #molstar-viewer [class*="SelectionMode"],
        #molstar-viewer [class*="selection-mode"] {
            display: none !important;
        }
        
        /* Hide all Mol* viewport toolbar buttons by default */
        #molstar-viewer .msp-viewport-controls button {
            display: none !important;
        }
        
        /* Show only our reset zoom button (marked by JS with .molstar-show-reset class) */
        #molstar-viewer .msp-viewport-controls button.molstar-show-reset {
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            padding: 0;
            background-color: #E4E0DD !important;  /* opaque, matches canvas */
            border-radius: 8px;
            border: 1px solid #C3BEB5;             /* subtle border for contrast */
            box-shadow: none !important;
        }
        
        /* Center the SVG icon inside the button */
        #molstar-viewer .msp-viewport-controls button.molstar-show-reset .msp-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Size the SVG to fit comfortably */
        #molstar-viewer .msp-viewport-controls button.molstar-show-reset svg {
            width: 18px;
            height: 18px;
        }
        
        /* Hover state for reset button */
        #molstar-viewer .msp-viewport-controls button.molstar-show-reset:hover {
            border-color: #e94560;
        }
        
        /* Ensure viewport controls container itself is visible */
        #molstar-viewer .msp-viewport-controls {
            display: block !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }
        
        /* Disable Mol* hover-box wrapper so the gray menu never appears */
        #molstar-viewer .msp-hover-box-wrapper {
            pointer-events: none !important;
        }
        
        /* Re-enable pointer events on the inner buttons so they are clickable */
        #molstar-viewer .msp-hover-box-wrapper button {
            pointer-events: auto !important;
        }
        
        /* Hide the dropdown body (gray menu) completely */
        #molstar-viewer .msp-hover-box-body {
            display: none !important;
        }

        /* Custom structure hover tooltip - follows cursor */
        .structure-hover-tooltip {
            position: absolute;
            /* top/left set dynamically via JS to follow cursor */
            top: 0;
            left: 0;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #0f3460;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 0.85rem;
            color: #fff;
            pointer-events: none;
            z-index: 10000;  /* High z-index to appear above Mol* canvas */
            display: none;
            max-width: 250px;
            white-space: nowrap;
        }

        .structure-hover-tooltip.visible {
            display: block;
        }

        .structure-hover-tooltip .tooltip-residue {
            display: block;
            font-weight: 600;
            color: #e94560;
            margin-bottom: 4px;
        }

        .structure-hover-tooltip .tooltip-score {
            display: block;
            color: #ccc;
            font-size: 0.8rem;
            word-break: break-word;
        }

        .structure-hover-tooltip .tooltip-score-value {
            color: #fff;
            font-weight: 500;
        }

        .structure-toggle-btn {
            display: none !important; /* Hidden - using top bar buttons instead */
        }

        .structure-toggle-btn:hover {
            background: #e94560;
            color: white;
            width: 28px;
        }

        .structure-toggle-btn.collapsed {
            right: 0;
            border-left: 1px solid #0f3460;
            border-right: none;
            border-radius: 6px 0 0 6px;
        }
        
        /* Highlighted residue marker */
        .residue-highlight {
            position: absolute;
            pointer-events: none;
            border: 2px solid #e94560;
            background: rgba(233, 69, 96, 0.2);
            border-radius: 4px;
        }
        
        /* Color scheme selector */
        .structure-color-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }

        .structure-color-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .structure-color-label {
            font-size: 0.7rem;
            color: #888;
            white-space: nowrap;
        }

        #structure-color-select {
            flex: 1;
            padding: 4px 8px;
            font-size: 0.7rem;
            background: #1a1a2e;
            border: 1px solid #555;
            color: #ccc;
            border-radius: 4px;
        }

        #structure-color-select:focus {
            border-color: #e94560;
            outline: none;
        }

        .aggregation-toggle {
            display: flex;
            gap: 2px;
        }

        .agg-btn {
            padding: 3px 8px;
            font-size: 0.65rem;
            background: #1a1a2e;
            border: 1px solid #555;
            color: #aaa;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .agg-btn.active {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        .agg-btn:hover:not(.active) {
            border-color: #e94560;
        }

        .structure-colorbar {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 4px;
            min-height: 20px;  /* Reserve space to prevent layout shift */
            visibility: hidden;  /* Hidden by default but reserves space */
        }

        .structure-colorbar.visible {
            visibility: visible;
        }

        .structure-colorbar-gradient {
            flex: 1;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #555;
        }

        .structure-colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: #888;
        }

        /* Resize Dividers */
        .resize-divider {
            width: 5px;
            background: transparent;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
            z-index: 10;
            transition: background 0.2s;
        }

        .resize-divider:hover {
            background: rgba(233, 69, 96, 0.3);
        }

        .resize-divider.resizing {
            background: rgba(233, 69, 96, 0.6);
        }

        .resize-divider::after {
            content: '';
            position: absolute;
            top: 0;
            left: -2px;
            right: -2px;
            bottom: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Compressed Genome Viewer</h1>
        <p>Interactive visualization of constraint metrics in compressed coordinate space</p>
    </div>
    
    <div class="gene-display-banner">
        <span class="label">Genes in view:</span>
        <span id="genes-list" class="gene-list">Loading...</span>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Filter:</label>
            <select id="filter-select"></select>
        </div>
        <div class="control-group" style="position: relative;">
            <label>Search:</label>
            <div style="position: relative; display: inline-block;">
                <input type="text" id="search-input" placeholder="Gene name or chr:pos" autocomplete="off">
                <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
            </div>
            <button id="search-btn">Go</button>
        </div>
        <!-- Panel toggle buttons (Cursor-style) -->
        <div class="panel-toggles">
            <button id="left-panel-btn" class="panel-btn active" title="Toggle track panel">
                <svg viewBox="0 0 20 16" fill="currentColor">
                    <!-- Outer screen rectangle -->
                    <rect x="1" y="1" width="18" height="14" rx="1.5" fill="none" stroke="currentColor" stroke-width="1.5" />
                    <!-- Left sidebar panel (inside, 1px smaller all around) -->
                    <rect x="3.5" y="3.5" width="3" height="9" rx="0.5" />
                </svg>
            </button>
            <button id="right-panel-btn" class="panel-btn active" title="Toggle 3D structure panel">
                <svg viewBox="0 0 20 16" fill="currentColor">
                    <!-- Outer screen rectangle -->
                    <rect x="1" y="1" width="18" height="14" rx="1.5" fill="none" stroke="currentColor" stroke-width="1.5" />
                    <!-- Right sidebar panel (inside, 1px smaller all around) -->
                    <rect x="13.5" y="3.5" width="3" height="9" rx="0.5" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Hidden inputs for internal state (removed from UI but still used by JS) -->
    <div style="display: none;">
        <input type="number" id="start-input" value="0">
        <input type="number" id="end-input" value="1000">
        <button id="update-range-btn"></button>
        <input type="text" id="gene-aa-input">
        <input type="number" id="aa-start-input">
        <input type="number" id="aa-end-input">
        <button id="gene-aa-btn"></button>
    </div>

    <div class="main-container">
        <button id="panel-toggle" class="panel-toggle" title="Toggle track panel">◀</button>
        <div class="track-panel" id="track-panel">
            <!-- Selected tracks with drag reordering -->
            <div id="selected-tracks-container" class="selected-tracks-section" style="display: none;">
                <h4>Selected Tracks (drag to reorder)</h4>
                <div id="selected-tracks-list"></div>
            </div>

            <h3>Select Tracks <span id="track-count">(0 selected)</span></h3>
            <div id="track-list"></div>
        </div>

        <!-- Left resize divider -->
        <div class="resize-divider" id="left-divider"></div>

        <div class="visualization-panel" id="visualization-panel">
            <div id="chart-container">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <!-- Right resize divider -->
        <div class="resize-divider" id="right-divider"></div>

        <!-- Structure Panel Toggle (outside panel so it stays visible when collapsed) -->
        <button class="structure-toggle-btn" id="structure-toggle-btn" title="Hide 3D structure panel">▶</button>

        <!-- Structure Panel (Mol* 3D Viewer) -->
        <div class="structure-panel" id="structure-panel">
            <div class="structure-panel-header">
                <h3>3D Structure</h3>
            </div>
            
            <div class="structure-controls" id="structure-controls">
                <div class="structure-controls-content" id="structure-controls-content">
                    <div class="structure-color-controls">
                        <div class="structure-color-row">
                            <span class="structure-color-label">Color:</span>
                            <select id="structure-color-select" title="Select coloring scheme">
                                <option value="default" selected>(Choose Track)</option>
                                <!-- Dynamically populated from selectedTracks -->
                            </select>
<select id="structure-aggregation-select" title="Aggregate per-position values">
  <option value="mean">mean</option>
  <option value="max">max</option>
  <option value="min">min</option>
</select>
                            <span class="structure-color-label" style="margin-left: 10px;">Agg:</span>
                            <div class="aggregation-toggle">
                                <button class="agg-btn active" data-agg="max" title="Use maximum value at each residue">Max</button>
                                <button class="agg-btn" data-agg="min" title="Use minimum value at each residue">Min</button>
                                <button class="agg-btn" data-agg="mean" title="Use mean value at each residue">Mean</button>
                            </div>
                        </div>
                        <div class="structure-colorbar" id="structure-colorbar">
                            <span class="structure-colorbar-min">0</span>
                            <div class="structure-colorbar-gradient" id="structure-colorbar-gradient"></div>
                            <span class="structure-colorbar-max">1</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="structure-viewer-container">
                <div id="molstar-viewer"></div>
                <!-- Custom tooltip overlaid inside viewer container -->
                <div id="structure-tooltip" class="structure-hover-tooltip"></div>
            </div>
            
        </div>
        
        <!-- Structure panel toggle button (shown when panel is closed) -->
    </div>
    
    <div class="status-bar">
        <span id="status-text">Ready</span>
        <span id="position-info"></span>
    </div>
    
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script type="module">
        // Import Mol* plugin functions from ES module
        import {
            initMolstarPlugin,
            getPlugin,
            loadStructure,
            removeHalo,
            createSphereHalo,
            extractCentralAtomLoci,
            resetCamera,
            subscribeToClicks,
            disableDefaultBehaviors,
            createTrackOverlaySpheres,
            removeTrackOverlaySpheres,
            clearAllTrackOverlays,
            hasTrackOverlay,
            getOverlayedTracks,
            StateTransforms,
            StructureElement,
            Color
        } from './src/molstar-plugin.ts';

        // Make available globally for debugging and internal use
        window.molstarAPI = {
            initMolstarPlugin,
            getPlugin,
            loadStructure,
            removeHalo,
            createSphereHalo,
            extractCentralAtomLoci,
            resetCamera,
            subscribeToClicks,
            disableDefaultBehaviors,
            createTrackOverlaySpheres,
            removeTrackOverlaySpheres,
            clearAllTrackOverlays,
            hasTrackOverlay,
            getOverlayedTracks,
            StateTransforms,
            StructureElement
        };

        // Debug flag - set to true to enable debug logging for residue mapping
        const DEBUG_RESIDUE_MAPPING = true;  // Enable to see zoom behavior in console

        // Configuration
        const API_BASE = '';
        const TRACK_HEIGHT = 60;
        const MARGIN = { top: 40, right: 120, bottom: 100, left: 150 };
        const COMPARATOR_TRACKS = new Set([
            'phylop_scores_447way',
            'phylop_scores_100way',
            'phylop17way',
            'MTR_RGC',
            'Non_Neuro_CCR_resid_pctile',
            'AlphaMissense_am_pathogenicity',
            'ESM1b_score',
        ]);
        
        // State
        let currentFilter = 'missense_only';
        let currentRange = [0, 1000];
        let selectedTracks = ['rgc_mis_count'];  // Array to maintain order
        let trackData = {};
        let positionsData = [];
        let draggedTrack = null;  // For drag-and-drop reordering
        let crosshairEnabled = true; // crosshair always active
        let axisMode = 'genomic'; // 'genomic' or 'aa'
        let panEnabled = true; // Pan mode toggle state
        let brushSelection = null; // Box select state
        let rangeBeforeBoxSelect = null; // Store range before box-select for reset
        // Percentile tracks are now included directly in the track selector
        let flippedTracks = new Set(); // Tracks with flipped color scales

        // Track rendering state - stored globally for crosshair/highlight sync
        let trackXScale = null;      // The base xScale used for rendering tracks
        let trackPlotWidth = null;   // The inner plot width (excluding margins)

        // Map of track fieldIds to their percentile equivalents
        // Dynamically generate the map for O/E and VIR tracks
        const PERCENTILE_MAP = {};

        // Generate O/E percentile mappings
        ['mis', 'syn', 'any'].forEach(consequence => {
            ['3bp', '9bp', '21bp', '45bp', '93bp'].forEach(window => {
                ['af0epos00', 'af1eneg06', 'af1eneg05', 'af1eneg04', 'af1eneg03', 'af1eneg02'].forEach(af => {
                    const baseField = `rgc_${consequence}_exomes_XX_XY_${window}_oe_${af}`;
                    const percField = `dbnsfp.max_${baseField}_exome_perc`;
                    PERCENTILE_MAP[baseField] = percField;
                });
            });
        });

        // Generate VIR percentile mappings
        ['mis', 'syn', 'any'].forEach(consequence => {
            ['vir_length', 'vir_depth', 'vir_mu_exp', 'mean_vir_exp'].forEach(virType => {
                ['af0epos00', 'af1eneg06', 'af1eneg05', 'af1eneg04', 'af1eneg03', 'af1eneg02'].forEach(af => {
                    const baseField = `rgc_${consequence}_exomes_XX_XY_${virType}_${af}`;
                    const percField = `dbnsfp.max_${baseField}_exome_perc`;
                    PERCENTILE_MAP[baseField] = percField;
                });
            });
        });

        // AA-level VIR tracks (missense only)
        ['aa_vir_depth', 'aa_vir_length'].forEach(virType => {
            ['af0epos00', 'af1eneg06', 'af1eneg05', 'af1eneg04', 'af1eneg03', 'af1eneg02'].forEach(af => {
                const baseField = `rgc_mis_exomes_XX_XY_${virType}_${af}`;
                const percField = `dbnsfp.max_${baseField}_exome_perc`;
                PERCENTILE_MAP[baseField] = percField;
            });
        });

        // Helper to get the effective field ID (percentile tracks are now selected directly)
        function getEffectiveFieldId(trackId) {
            return trackId;
        }

        // Check if a track is a percentile version
        function isPercentileTrack(trackId) {
            return trackId.includes('_perc') || trackId.includes('percentile');
        }

        // Helper to add percentile versions to track tree nodes
        function addPercentileVersions(node) {
            if (node.fieldId && PERCENTILE_MAP[node.fieldId]) {
                // This is a leaf node with a percentile version - return both raw and percentile
                return [
                    node,
                    { label: node.label + ' %', fieldId: PERCENTILE_MAP[node.fieldId] }
                ];
            } else if (node.children) {
                // Recursively process children
                const newChildren = [];
                for (const child of node.children) {
                    const processed = addPercentileVersions(child);
                    if (Array.isArray(processed)) {
                        newChildren.push(...processed);
                    } else {
                        newChildren.push(processed);
                    }
                }
                return { ...node, children: newChildren };
            }
            return node;
        }

        // Hierarchical track tree (O/E ratios and VIRs)
        const VIR_AF_LEVELS = [
            { label: '(0)', suffix: 'af0epos00' },
            { label: '(10⁻⁶)', suffix: 'af1eneg06' },
            { label: '(10⁻⁵)', suffix: 'af1eneg05' },
            { label: '(10⁻⁴)', suffix: 'af1eneg04' },
            { label: '(10⁻³)', suffix: 'af1eneg03' },
            { label: '(10⁻²)', suffix: 'af1eneg02' }
        ];

        const ADDITIONAL_SECTIONS = [
            {
                label: 'Domains',
                children: [
                    { label: 'ID (InterPro)', fieldId: 'domain_id_interpro' },
                    { label: 'Name', fieldId: 'domain_name' },
                    { label: 'Type', fieldId: 'domain_type' },
                    { label: 'Source DB', fieldId: 'source_db' },
                ]
            },
            {
                label: 'Conservation',
                children: [
                    { label: 'phyloP 447-way', fieldId: 'phylop_scores_447way' },
                    { label: 'phyloP 100-way', fieldId: 'phylop_scores_100way' },
                    { label: 'phyloP 17-way', fieldId: 'phylop17way' },
                ]
            },
            {
                label: 'Constraint',
                children: [
                    { label: 'MTR', fieldId: 'MTR_RGC' },
                    { label: 'Non-neuro CCR Residual Percentile', fieldId: 'Non_Neuro_CCR_resid_pctile' },
                ]
            },
            {
                label: 'Pathogenicity / Model Scores',
                children: [
                    { label: 'AlphaMissense', fieldId: 'AlphaMissense_am_pathogenicity' },
                    { label: 'ESM1b', fieldId: 'ESM1b_score' },
                ]
            },
            {
                label: 'Counts',
                children: [
                    { label: 'Any', fieldId: 'rgc_any_count' },
                    { label: 'Synonymous', fieldId: 'rgc_syn_count' },
                    { label: 'Missense', fieldId: 'rgc_mis_count' },
                ]
            },
            {
                label: 'Summary',
                children: [
                    {
                        label: 'Any',
                        children: [
                            { label: 'Observed', fieldId: 'rgc_any_obs_exomes_XX_XY' },
                            { label: 'Expected μ', fieldId: 'rgc_any_prob_mu_exomes_XX_XY' },
                            { label: 'Max AF', fieldId: 'rgc_any_max_af' },
                        ]
                    },
                    {
                        label: 'Synonymous',
                        children: [
                            { label: 'Observed', fieldId: 'rgc_syn_obs_exomes_XX_XY' },
                            { label: 'Expected μ', fieldId: 'rgc_syn_prob_mu_exomes_XX_XY' },
                            { label: 'Max AF', fieldId: 'rgc_syn_max_af' },
                        ]
                    },
                    {
                        label: 'Missense',
                        children: [
                            { label: 'Observed', fieldId: 'rgc_mis_obs_exomes_XX_XY' },
                            { label: 'Expected μ', fieldId: 'rgc_mis_prob_mu_exomes_XX_XY' },
                            { label: 'Max AF', fieldId: 'rgc_mis_max_af' },
                        ]
                    },
                ]
            },
        ];

        // Simplified explicit track tree (mirrors backend)
        const TRACK_TREE = {
            label: 'Tracks',
            children: [
                {
                    label: 'Counts',
                    children: [
                        { label: 'Any', fieldId: 'rgc_any_count' },
                        { label: 'Synonymous', fieldId: 'rgc_syn_count' },
                        { label: 'Missense', fieldId: 'rgc_mis_count' },
                    ],
                },
                {
                    label: 'RGC',
                    children: [
                        {
                            label: 'Summary',
                            children: [
                                {
                                    label: 'Any',
                                    children: [
                                        { label: 'Observed', fieldId: 'rgc_any_obs_exomes_XX_XY' },
                                        { label: 'Expected μ', fieldId: 'rgc_any_prob_mu_exomes_XX_XY' },
                                        { label: 'Max AF', fieldId: 'rgc_any_max_af' },
                                    ],
                                },
                                {
                                    label: 'Synonymous',
                                    children: [
                                        { label: 'Observed', fieldId: 'rgc_syn_obs_exomes_XX_XY' },
                                        { label: 'Expected μ', fieldId: 'rgc_syn_prob_mu_exomes_XX_XY' },
                                        { label: 'Max AF', fieldId: 'rgc_syn_max_af' },
                                    ],
                                },
                                {
                                    label: 'Missense',
                                    children: [
                                        { label: 'Observed', fieldId: 'rgc_mis_obs_exomes_XX_XY' },
                                        { label: 'Expected μ', fieldId: 'rgc_mis_prob_mu_exomes_XX_XY' },
                                        { label: 'Max AF', fieldId: 'rgc_mis_max_af' },
                                    ],
                                },
                            ],
                        },
                        {
                            label: 'O/E Ratios',
                            children: [
                                {
                                    label: 'Missense',
                                    children: [
                                        {
                                            label: '3bp',
                                            children: [
                                                {
                                                    label: 'O/E',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_3bp_oe_af0epos00' }
                                                    ]
                                                },
                                                {
                                                    label: 'Expected',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_3bp_e_af0epos00' }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            label: '9bp',
                                            children: [
                                                {
                                                    label: 'O/E',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_9bp_oe_af0epos00' }
                                                    ]
                                                },
                                                {
                                                    label: 'Expected',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_9bp_e_af0epos00' }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            label: '21bp',
                                            children: [
                                                {
                                                    label: 'O/E',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_oe_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_oe_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_oe_af1eneg04' }
                                                    ]
                                                },
                                                {
                                                    label: 'Expected',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_e_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_e_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_21bp_e_af1eneg04' }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            label: '45bp',
                                            children: [
                                                {
                                                    label: 'O/E',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_oe_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_oe_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_oe_af1eneg04' }
                                                    ]
                                                },
                                                {
                                                    label: 'Expected',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_e_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_e_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_45bp_e_af1eneg04' }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            label: '93bp',
                                            children: [
                                                {
                                                    label: 'O/E',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_oe_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_oe_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_oe_af1eneg04' }
                                                    ]
                                                },
                                                {
                                                    label: 'Expected',
                                                    children: [
                                                        { label: '(0)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_e_af0epos00' },
                                                        { label: '(10⁻⁶)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_e_af1eneg06' },
                                                        { label: '(10⁻⁴)', fieldId: 'rgc_mis_exomes_XX_XY_93bp_e_af1eneg04' }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    label: 'Synonymous',
                                    children: ['3bp','9bp','21bp','45bp','93bp'].map(bp => ({
                                        label: `${bp}`,
                                        children: [
                                            {
                                                label: 'O/E',
                                                children: [
                                                    { label: '(0)', fieldId: `rgc_syn_exomes_XX_XY_${bp}_oe_af0epos00` }
                                                ]
                                            },
                                            {
                                                label: 'Expected',
                                                children: [
                                                    { label: '(0)', fieldId: `rgc_syn_exomes_XX_XY_${bp}_e_af0epos00` }
                                                ]
                                            }
                                        ]
                                    }))
                                },
                                {
                                    label: 'Any',
                                    children: ['3bp','9bp','21bp','45bp','93bp'].map(bp => ({
                                        label: `${bp}`,
                                        children: [
                                            {
                                                label: 'O/E',
                                                children: [
                                                    { label: '(0)', fieldId: `rgc_any_exomes_XX_XY_${bp}_oe_af0epos00` }
                                                ]
                                            },
                                            {
                                                label: 'Expected',
                                                children: [
                                                    { label: '(0)', fieldId: `rgc_any_exomes_XX_XY_${bp}_e_af0epos00` }
                                                ]
                                            }
                                        ]
                                    }))
                                }
                            ]
                        },
                        {
                            label: 'VIRs',
                            children: [
                                {
                                    label: 'Missense',
                                    children: [
                                        {
                                            label: '(0)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af0epos00' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af0epos00' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af0epos00' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af0epos00' }
                                            ]
                                        },
                                        {
                                            label: '(10⁻⁶)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af1eneg06' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af1eneg06' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af1eneg06' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af1eneg06' }
                                            ]
                                        },
                                        {
                                            label: '(10⁻⁵)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af1eneg05' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af1eneg05' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af1eneg05' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af1eneg05' }
                                            ]
                                        },
                                        {
                                            label: '(10⁻⁴)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af1eneg04' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af1eneg04' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af1eneg04' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af1eneg04' }
                                            ]
                                        },
                                        {
                                            label: '(10⁻³)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af1eneg03' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af1eneg03' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af1eneg03' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af1eneg03' }
                                            ]
                                        },
                                        {
                                            label: '(10⁻²)',
                                            children: [
                                                { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_vir_length_af1eneg02' },
                                                { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_vir_depth_af1eneg02' },
                                                { label: 'Expected μ', fieldId: 'rgc_mis_exomes_XX_XY_vir_mu_exp_af1eneg02' },
                                                { label: 'Mean Expected', fieldId: 'rgc_mis_exomes_XX_XY_mean_vir_exp_af1eneg02' }
                                            ]
                                        },
                                        {
                                            label: 'AA Level',
                                            children: [
                                                {
                                                    label: '(0)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af0epos00' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af0epos00' }
                                                    ]
                                                },
                                                {
                                                    label: '(10⁻⁶)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af1eneg06' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af1eneg06' }
                                                    ]
                                                },
                                                {
                                                    label: '(10⁻⁵)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af1eneg05' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af1eneg05' }
                                                    ]
                                                },
                                                {
                                                    label: '(10⁻⁴)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af1eneg04' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af1eneg04' }
                                                    ]
                                                },
                                                {
                                                    label: '(10⁻³)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af1eneg03' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af1eneg03' }
                                                    ]
                                                },
                                                {
                                                    label: '(10⁻²)',
                                                    children: [
                                                        { label: 'Depth', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_depth_af1eneg02' },
                                                        { label: 'Length', fieldId: 'rgc_mis_exomes_XX_XY_aa_vir_length_af1eneg02' }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                },
                                {
                                    label: 'Synonymous',
                                    children: VIR_AF_LEVELS.map(({ label, suffix }) => ({
                                        label,
                                        children: [
                                            { label: 'Length', fieldId: `rgc_syn_exomes_XX_XY_vir_length_${suffix}` },
                                            { label: 'Depth', fieldId: `rgc_syn_exomes_XX_XY_vir_depth_${suffix}` },
                                            { label: 'Expected μ', fieldId: `rgc_syn_exomes_XX_XY_vir_mu_exp_${suffix}` },
                                            { label: 'Mean Expected', fieldId: `rgc_syn_exomes_XX_XY_mean_vir_exp_${suffix}` }
                                        ]
                                    }))
                                },
                                {
                                    label: 'Any',
                                    children: VIR_AF_LEVELS.map(({ label, suffix }) => ({
                                        label,
                                        children: [
                                            { label: 'Length', fieldId: `rgc_any_exomes_XX_XY_vir_length_${suffix}` },
                                            { label: 'Depth', fieldId: `rgc_any_exomes_XX_XY_vir_depth_${suffix}` },
                                            { label: 'Expected μ', fieldId: `rgc_any_exomes_XX_XY_vir_mu_exp_${suffix}` },
                                            { label: 'Mean Expected', fieldId: `rgc_any_exomes_XX_XY_mean_vir_exp_${suffix}` }
                                        ]
                                    }))
                                }
                            ]
                        }
                    ]
                },
                // ClinVar
                {
                    label: 'ClinVar',
                    children: [
                        { label: 'Labels (Stacked)', fieldId: 'clinvar.clinvar_label_list' },
                        { label: 'Variant Count', fieldId: 'clinvar.clinvar_count' },
                    ],
                },
                // Training Labels
                {
                    label: 'Training Labels',
                    children: [
                        { label: 'Labelled', fieldId: 'training.train_counts.labelled' },
                        { label: 'Unlabelled', fieldId: 'training.train_counts.unlabelled' },
                        { label: 'Labelled (High Qual)', fieldId: 'training.train_counts.labelled_high_qual' },
                        { label: 'Unlabelled (High Qual)', fieldId: 'training.train_counts.unlabelled_high_qual' },
                    ],
                },
                // Domains (updated for array format)
                {
                    label: 'Domains',
                    children: [
                        { label: 'All Domains', fieldId: 'domains' },
                    ],
                },
                // Constraint Predictions
                {
                    label: 'Constraint Predictions',
                    children: [
                        { label: 'Constraint_1000', fieldId: 'Constraint' },
                        { label: 'Core_1000', fieldId: 'Core' },
                        { label: 'Complete_1000', fieldId: 'Complete' },
                    ],
                },
                // Comparators (updated with dbNSFP fields)
                {
                    label: 'Comparators',
                    children: [
                        {
                            label: 'Conservation',
                            children: [
                                { label: 'phyloP 447-way', fieldId: 'phylop_scores_447way' },
                                { label: 'phyloP 100-way', fieldId: 'phylop_scores_100way' },
                                { label: 'phyloP 17-way', fieldId: 'phylop17way' },
                            ],
                        },
                        {
                            label: 'Constraint',
                            children: [
                                { label: 'MTR (dbNSFP)', fieldId: 'dbnsfp.max_RGC_MTR_MTR' },
                                { label: 'MTR Percentile', fieldId: 'dbnsfp.max_RGC_MTR_MTRpercentile_exome' },
                                { label: 'CCR Residual Percentile', fieldId: 'dbnsfp.max_Non_Neuro_CCR_resid_pctile' },
                            ],
                        },
                        {
                            label: 'Pathogenicity / Model Scores',
                            children: [
                                { label: 'AlphaMissense', fieldId: 'dbnsfp.max_AlphaMissense_am_pathogenicity' },
                                { label: 'ESM1b', fieldId: 'dbnsfp.max_ESM1b_score' },
                            ],
                        },
                        {
                            label: 'AlphaSync',
                            children: [
                                { label: 'pLDDT', fieldId: 'dbnsfp.max_AlphaSync_plddt' },
                                { label: 'pLDDT (10-window)', fieldId: 'dbnsfp.max_AlphaSync_plddt10' },
                                { label: 'RelASA', fieldId: 'dbnsfp.max_AlphaSync_relasa' },
                                { label: 'RelASA (10-window)', fieldId: 'dbnsfp.max_AlphaSync_relasa10' },
                            ],
                        },
                    ],
                },
            ],
        };
        
        // Helper: Simplify track names
        function simplifyTrackName(trackId) {
            // Direct mappings for new annotation tracks
            const directMappings = {
                'MTR_RGC': 'MTR',
                'Non_Neuro_CCR_resid_pctile': 'CCR',
                'AlphaMissense_am_pathogenicity': 'AlphaMissense',
                'phylop_scores_447way': 'phyloP 447way',
                'phylop_scores_100way': 'phyloP 100way',
                'phylop17way': 'phyloP 17way',
                'ESM1b_score': 'ESM1b',
                'domain_name': 'Domains',
                'domain_id_interpro': 'Domain IDs',
                'domain_type': 'Domain Types',
                'source_db': 'Domain Sources',
                'domains': 'Protein Domains',
                // ClinVar
                'clinvar.clinvar_count': 'ClinVar Count',
                'clinvar.clinvar_label_list': 'ClinVar Labels',
                'clinvar.clinvar_status_list': 'ClinVar Status',
                'clinvar.clinvar_var_type_list': 'ClinVar Var Types',
                // Training
                'training.train_counts.labelled': 'Labelled',
                'training.train_counts.unlabelled': 'Unlabelled',
                'training.train_counts.labelled_high_qual': 'Labelled (HQ)',
                'training.train_counts.unlabelled_high_qual': 'Unlabelled (HQ)',
                // dbNSFP
                'dbnsfp.max_AlphaMissense_am_pathogenicity': 'AlphaMissense',
                'dbnsfp.max_RGC_MTR_MTR': 'MTR',
                'dbnsfp.max_RGC_MTR_MTRpercentile_exome': 'MTR Percentile',
                'dbnsfp.max_Non_Neuro_CCR_resid_pctile': 'CCR',
                'dbnsfp.max_ESM1b_score': 'ESM1b',
                'dbnsfp.max_AlphaSync_plddt': 'pLDDT',
                'dbnsfp.max_AlphaSync_plddt10': 'pLDDT (10)',
                'dbnsfp.max_AlphaSync_relasa': 'RelASA',
                'dbnsfp.max_AlphaSync_relasa10': 'RelASA (10)',
            };
            if (directMappings[trackId]) {
                return directMappings[trackId];
            }
            
            let name = trackId;

            // Check if this is a percentile track from dbnsfp
            const isPercTrack = name.includes('_exome_perc') || name.includes('percentile');

            // Remove dbnsfp.max_ prefix for percentile tracks
            name = name.replace(/^dbnsfp\.max_/, '');

            // Remove _exome_perc suffix (we'll add % indicator later)
            name = name.replace(/_exome_perc$/, '');

            // Remove prefixes
            name = name.replace(/^rgc_/, '');
            name = name.replace(/_exomes_/g, '_');
            name = name.replace(/exomes_/g, '');
            name = name.replace(/_XX_XY_/gi, '_');
            name = name.replace(/XX_XY_/gi, '');
            
            // Handle AF notation
            const toSuperscript = (num) => {
                const sups = {'0':'⁰','1':'¹','2':'²','3':'³','4':'⁴','5':'⁵','6':'⁶','7':'⁷','8':'⁸','9':'⁹','-':'⁻'};
                return num.split('').map(c => sups[c] || c).join('');
            };
            
            name = name.replace(/_af(\d+)e(pos|neg)(\d+)/gi, (m, coef, sign, exp) => {
                const expNum = parseInt(exp, 10);
                if (expNum === 0) return '';
                const exponent = sign.toLowerCase() === 'neg' ? `-${expNum}` : `${expNum}`;
                return ` AF≤10${toSuperscript(exponent)}`;
            });
            name = name.replace(/af(\d+)e(pos|neg)(\d+)/gi, (m, coef, sign, exp) => {
                const expNum = parseInt(exp, 10);
                if (expNum === 0) return '';
                const exponent = sign.toLowerCase() === 'neg' ? `-${expNum}` : `${expNum}`;
                return `AF≤10${toSuperscript(exponent)}`;
            });
            
            // Replace underscores
            name = name.replace(/_/g, ' ');
            
            // Fix labels
            name = name.replace(/\bBp\b/gi, 'bp');
            name = name.replace(/\b([a-zA-Z]+\s+\d+bp)\s+[eE]\b/g, '$1 Exp');
            name = name.replace(/\b([a-zA-Z]+)\s+[eE]\b/g, '$1 Exp');
            name = name.replace(/\bOe\b/gi, 'O/E');
            
            // Clean up
            name = name.replace(/\s+/g, ' ').trim();

            // Add percentile indicator for percentile tracks
            if (isPercTrack) {
                name = name + ' %';
            }

            return name;
        }

        // Determine if track is O/E type
        function isOETrack(trackId) {
            return trackId.toLowerCase().includes('_oe_') || trackId.toLowerCase().includes('_oe');
        }
        
        // Determine if track is a Domain track (presence/absence)
        function isDomainTrack(trackId) {
            return trackId === 'domain_name' || trackId === 'domains';
        }

        // Determine if track is a ClinVar stacked labels track
        function isClinVarStackedTrack(trackId) {
            return trackId === 'clinvar.clinvar_label_list';
        }

        // Determine if track is a Constraint stacked track
        function isConstraintStackedTrack(trackId) {
            return trackId === 'Constraint' || trackId === 'Core' || trackId === 'Complete';
        }

        // Determine if track is a dbNSFP stacked track
        function isDbNSFPStackedTrack(trackId) {
            return trackId === 'AlphaMissense_stacked' || trackId === 'ESM1b_stacked';
        }

        // Determine if track is a ClinVar variants track (new struct format)
        function isClinVarVariantsTrack(trackId) {
            return trackId === 'clinvar_variants';
        }

        // Determine if track is a variant frequency track
        function isVariantFrequencyTrack(trackId) {
            return trackId === 'rgc_variants' ||
                   trackId === 'gnomad_exomes_variants' ||
                   trackId === 'gnomad_genomes_variants';
        }

        // Determine if track is a coverage track
        function isCoverageTrack(trackId) {
            return trackId.startsWith('gnomad_exomes_') && (trackId.includes('mean') || trackId.includes('median') || trackId.includes('over_')) ||
                   trackId.startsWith('gnomad_genomes_') && (trackId.includes('mean') || trackId.includes('median') || trackId.includes('over_'));
        }

        // Coverage track colors
        const COVERAGE_COLORS = {
            'exome': 'rgba(66, 133, 244, 0.7)',   // Blue with transparency
            'genome': 'rgba(52, 168, 83, 0.7)'   // Green with transparency
        };

        // Determine if track is any ClinVar track
        function isClinVarTrack(trackId) {
            return trackId.startsWith('clinvar.') || trackId === 'clinvar_variants';
        }

        // Determine if track is a training labels track
        function isTrainingTrack(trackId) {
            return trackId.startsWith('training.');
        }

        // Determine if track is counts
        function isCountsTrack(trackId) {
            return trackId.endsWith('_count') || trackId.endsWith('.clinvar_count');
        }

        // Determine if track is observed (summary)
        function isObservedTrack(trackId) {
            return /_obs_/i.test(trackId);
        }

        // Determine if track is summary expected mu or max af
        function isSummaryExpectedTrack(trackId) {
            return /_prob_mu_/i.test(trackId) || trackId.endsWith('_max_af');
        }

        // Determine if track is an RGC summary track (not O/E ratios)
        function isRGCSummaryTrack(trackId) {
            return trackId.startsWith('rgc_') && !/_oe_/i.test(trackId) && !/_e_af/i.test(trackId);
        }

        // Determine if track should use constraint prediction colors (RdYlGn)
        function usesConstraintColors(trackId) {
            return isCountsTrack(trackId) ||
                   isRGCSummaryTrack(trackId) ||
                   COMPARATOR_TRACKS.has(trackId) ||
                   isTrainingTrack(trackId);
        }
        
        // Domain-related columns for tooltip
        const DOMAIN_COLUMNS = ['domain_name', 'domain_id_interpro', 'domain_type', 'source_db', 'domains'];

        // ClinVar label colors and priority
        // ClinVar label definitions with colors and abbreviations
        const CLINVAR_LABELS = {
            'Pathogenic': { abbrev: 'P', color: '#d62728', priority: 1 },
            'Likely_pathogenic': { abbrev: 'LP', color: '#ff7f0e', priority: 2 },
            'Pathogenic/Likely_pathogenic': { abbrev: 'P/LP', color: '#e74c3c', priority: 1.5 },
            'Uncertain_significance': { abbrev: 'VUS', color: '#bcbd22', priority: 3 },
            'Conflicting_interpretations_of_pathogenicity': { abbrev: 'Conf', color: '#9467bd', priority: 2.5 },
            'Likely_benign': { abbrev: 'LB', color: '#2ca02c', priority: 4 },
            'Benign': { abbrev: 'B', color: '#1f77b4', priority: 5 },
            'Benign/Likely_benign': { abbrev: 'B/LB', color: '#17a2b8', priority: 4.5 },
            'not_provided': { abbrev: 'N/A', color: '#999999', priority: 6 },
            'other': { abbrev: 'Other', color: '#666666', priority: 7 }
        };

        // ClinVar filter state - which labels to show (all enabled by default)
        let clinvarLabelFilter = {
            'Pathogenic': true,
            'Likely_pathogenic': true,
            'Uncertain_significance': true,
            'Likely_benign': true,
            'Benign': true
        };

        // Legacy CLINVAR_COLORS for backward compatibility
        const CLINVAR_COLORS = Object.fromEntries(
            Object.entries(CLINVAR_LABELS).map(([k, v]) => [k, v.color])
        );

        // Variant consequence categories for filtering constraint predictions
        // Categories: plof, missense, synonymous, other
        const CONSEQUENCE_CATEGORIES = {
            'plof': { abbrev: 'pLoF', color: '#d62728', description: 'Predicted Loss of Function' },
            'missense': { abbrev: 'Missense', color: '#ff7f0e', description: 'Missense variants' },
            'synonymous': { abbrev: 'Synonymous', color: '#2ca02c', description: 'Synonymous variants' },
            'other': { abbrev: 'Other', color: '#7f7f7f', description: 'Other consequence types' }
        };

        // Consequence filter state - which categories to show (all enabled by default)
        let consequenceFilter = {
            'plof': true,
            'missense': true,
            'synonymous': true,
            'other': true
        };

        // Check if a consequence category passes the current filter
        function consequencePassesFilter(csqCategory) {
            if (!csqCategory) return true;  // If no category, show by default
            return consequenceFilter[csqCategory] !== false;
        }

        // Get consequence for an allele at a position from positionsData
        function getConsequenceForAllele(positionData, allele) {
            const csqArray = positionData['variant_consequences'];
            if (!csqArray || !Array.isArray(csqArray)) return null;

            // Find the consequence for this allele (using new struct fields: alt, csq)
            for (const csq of csqArray) {
                if (csq && csq.alt === allele) {
                    return csq.csq;  // Return the consequence category
                }
            }
            return null;
        }

        // Variant frequency track constants
        const COHORT_COLORS = {
            'gnomad_exomes_variants': '#4285F4',   // Blue
            'gnomad_genomes_variants': '#34A853',  // Green
            'rgc_variants': '#FF6D00'              // Orange
        };

        // Filter state for variant frequencies (show non-PASS variants)
        let showFilteredVariants = true;

        // Track overlay state for 3D structure visualization
        // Max 2 overlays allowed at once
        const TRACK_OVERLAY_COLORS = [0x0066CC, 0x00CED1];  // Blue, Cyan
        const TRACK_OVERLAY_COLOR_NAMES = ['#0066CC', '#00CED1'];
        let trackOverlayState = {
            overlayedTracks: [],  // [{trackId, colorSlot}], max 2
            sphereRefs: new Map()
        };

        // Check if a track is eligible for sphere overlay
        function isEligibleForSphereOverlay(trackId) {
            return isClinVarVariantsTrack(trackId) ||
                   isTrainingTrack(trackId) ||
                   isConstraintStackedTrack(trackId);
        }

        // Get residues that have data for a track
        function getResiduesWithTrackData(trackId) {
            if (!currentData || !currentData.track_data) return [];

            const trackData = currentData.track_data[trackId];
            if (!trackData) return [];

            const residuesWithData = new Set();
            const positions = Object.keys(trackData);

            for (const pos of positions) {
                const value = trackData[pos];

                // Check if position has valid data
                let hasData = false;

                if (isClinVarVariantsTrack(trackId)) {
                    // ClinVar: check if any variants pass the filter
                    if (Array.isArray(value) && value.length > 0) {
                        for (const v of value) {
                            if (v.significance && clinvarLabelPassesFilter(v.significance)) {
                                hasData = true;
                                break;
                            }
                        }
                    }
                } else if (isTrainingTrack(trackId)) {
                    // Training: check for non-zero count
                    if (value && value > 0) hasData = true;
                } else if (isConstraintStackedTrack(trackId)) {
                    // Constraint: check if array has variants
                    if (Array.isArray(value) && value.length > 0) hasData = true;
                }

                if (hasData) {
                    // Map filtered position to protein residue
                    const filteredIdx = parseInt(pos);
                    const positionData = currentData.positions?.find(p => p.filtered_idx === filteredIdx);
                    if (positionData && positionData.protein_residue) {
                        residuesWithData.add(positionData.protein_residue);
                    }
                }
            }

            return Array.from(residuesWithData);
        }

        // Add track overlay
        async function addTrackOverlay(trackId) {
            if (!window.molstarLoaded) {
                console.warn('[OVERLAY] Mol* not loaded');
                return;
            }

            // Check max overlays
            if (trackOverlayState.overlayedTracks.length >= 2) {
                console.warn('[OVERLAY] Maximum 2 overlays allowed');
                return;
            }

            // Check if already overlayed
            if (trackOverlayState.overlayedTracks.some(t => t.trackId === trackId)) {
                console.log('[OVERLAY] Track already overlayed:', trackId);
                return;
            }

            // Find next available color slot
            const usedSlots = new Set(trackOverlayState.overlayedTracks.map(t => t.colorSlot));
            let colorSlot = 0;
            if (usedSlots.has(0)) colorSlot = 1;

            // Get residues with data
            const residues = getResiduesWithTrackData(trackId);
            if (residues.length === 0) {
                console.warn('[OVERLAY] No residues with data for track:', trackId);
                return;
            }

            console.log(`[OVERLAY] Adding overlay for ${trackId} with ${residues.length} residues, color slot ${colorSlot}`);

            try {
                const refs = await createTrackOverlaySpheres(
                    residues,
                    TRACK_OVERLAY_COLORS[colorSlot],
                    trackId,
                    3.0,  // sizeFactor
                    0.7   // alpha
                );

                trackOverlayState.overlayedTracks.push({ trackId, colorSlot });
                trackOverlayState.sphereRefs.set(trackId, refs);

                // Update UI
                updateTrackOverlayButtons();
            } catch (e) {
                console.error('[OVERLAY] Failed to add overlay:', e);
            }
        }

        // Remove track overlay
        async function removeTrackOverlay(trackId) {
            if (!window.molstarLoaded) return;

            const idx = trackOverlayState.overlayedTracks.findIndex(t => t.trackId === trackId);
            if (idx === -1) return;

            try {
                await removeTrackOverlaySpheres(trackId);
                trackOverlayState.overlayedTracks.splice(idx, 1);
                trackOverlayState.sphereRefs.delete(trackId);

                // Update UI
                updateTrackOverlayButtons();
            } catch (e) {
                console.error('[OVERLAY] Failed to remove overlay:', e);
            }
        }

        // Update track overlay spheres when filters change
        async function updateTrackOverlaySpheres(trackId) {
            if (!window.molstarLoaded) return;

            const overlay = trackOverlayState.overlayedTracks.find(t => t.trackId === trackId);
            if (!overlay) return;

            const residues = getResiduesWithTrackData(trackId);
            console.log(`[OVERLAY] Updating overlay for ${trackId} with ${residues.length} residues`);

            try {
                await removeTrackOverlaySpheres(trackId);

                if (residues.length > 0) {
                    const refs = await createTrackOverlaySpheres(
                        residues,
                        TRACK_OVERLAY_COLORS[overlay.colorSlot],
                        trackId,
                        3.0,
                        0.7
                    );
                    trackOverlayState.sphereRefs.set(trackId, refs);
                }
            } catch (e) {
                console.error('[OVERLAY] Failed to update overlay:', e);
            }
        }

        // Update overlay buttons in track headers
        function updateTrackOverlayButtons() {
            document.querySelectorAll('.track-overlay-btn').forEach(btn => {
                const trackId = btn.dataset.trackId;
                const isOverlayed = trackOverlayState.overlayedTracks.some(t => t.trackId === trackId);
                const overlay = trackOverlayState.overlayedTracks.find(t => t.trackId === trackId);

                btn.classList.toggle('active', isOverlayed);
                if (isOverlayed && overlay) {
                    btn.style.backgroundColor = TRACK_OVERLAY_COLOR_NAMES[overlay.colorSlot];
                    btn.style.color = 'white';
                    btn.title = 'Remove 3D overlay';
                } else {
                    btn.style.backgroundColor = '';
                    btn.style.color = '';
                    btn.title = 'Show on 3D structure';
                }
            });
        }

        function getClinVarColor(label) {
            // Try exact match first
            if (CLINVAR_COLORS[label]) return CLINVAR_COLORS[label];
            // Try partial match
            const labelLower = label.toLowerCase();
            if (labelLower.includes('pathogenic') && !labelLower.includes('benign')) return CLINVAR_COLORS['Pathogenic'];
            if (labelLower.includes('benign')) return CLINVAR_COLORS['Benign'];
            if (labelLower.includes('uncertain')) return CLINVAR_COLORS['Uncertain_significance'];
            if (labelLower.includes('conflict')) return CLINVAR_COLORS['Conflicting_interpretations_of_pathogenicity'];
            return CLINVAR_COLORS['other'];
        }

        // Normalize ClinVar label to a canonical form for filtering
        function normalizeClinVarLabel(label) {
            const labelLower = label.toLowerCase();
            if (labelLower.includes('pathogenic') && labelLower.includes('likely') && !labelLower.includes('benign')) return 'Likely_pathogenic';
            if (labelLower.includes('pathogenic') && !labelLower.includes('benign') && !labelLower.includes('likely')) return 'Pathogenic';
            if (labelLower.includes('benign') && labelLower.includes('likely')) return 'Likely_benign';
            if (labelLower.includes('benign') && !labelLower.includes('likely')) return 'Benign';
            if (labelLower.includes('uncertain')) return 'Uncertain_significance';
            if (labelLower.includes('conflict')) return 'Conflicting_interpretations_of_pathogenicity';
            return label; // Return original if no match
        }

        // Check if a ClinVar label passes the current filter
        function clinvarLabelPassesFilter(label) {
            const normalized = normalizeClinVarLabel(label);
            // Check if the normalized label is in our filter set
            if (clinvarLabelFilter.hasOwnProperty(normalized)) {
                return clinvarLabelFilter[normalized];
            }
            // For labels not in our filter (like P/LP, B/LB, Conf), check component parts
            const labelLower = label.toLowerCase();
            if (labelLower.includes('pathogenic') && !labelLower.includes('benign')) {
                return clinvarLabelFilter['Pathogenic'] || clinvarLabelFilter['Likely_pathogenic'];
            }
            if (labelLower.includes('benign')) {
                return clinvarLabelFilter['Benign'] || clinvarLabelFilter['Likely_benign'];
            }
            // Default: show if any filter is enabled
            return true;
        }
        
        // Load filters
        async function loadFilters() {
            try {
                const response = await fetch(`${API_BASE}/api/filters`);
                const filters = await response.json();
                const select = document.getElementById('filter-select');
                select.innerHTML = filters.map(f => 
                    `<option value="${f.id}" ${f.id === currentFilter ? 'selected' : ''}>${f.name}</option>`
                ).join('');
                select.addEventListener('change', () => {
                    currentFilter = select.value;
                    loadData();
                });
            } catch (e) {
                console.error('Failed to load filters:', e);
            }
        }
        
        // Load track list from API
        async function loadTracks() {
            const container = document.getElementById('track-list');
            container.innerHTML = '';
            try {
                // Fetch track tree from backend API
                const response = await fetch(`${API_BASE}/api/track-tree`);
                const trackTree = await response.json();
                // Transform tree to include percentile versions for O/E tracks
                const treeWithPercentiles = addPercentileVersions(trackTree);
                renderTrackTree(treeWithPercentiles, container);
            } catch (e) {
                console.error('Failed to load track tree:', e);
                // Fallback to hardcoded tree if API fails
                const treeWithPercentiles = addPercentileVersions(TRACK_TREE);
                renderTrackTree(treeWithPercentiles, container);
            }
            document.getElementById('track-count').textContent = `(${selectedTracks.length} selected)`;
            updateSelectedTracksList();
        }

        // Render the hierarchical track tree with collapsible nodes
        function renderTrackTree(tree, container) {
            const root = document.createElement('div');
            renderTreeNode(tree, root, true);
            container.appendChild(root);
        }

        function renderTreeNode(node, parentEl, expanded = false) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'track-tree-node';
            
            if (node.children && node.children.length) {
                const header = document.createElement('div');
                header.className = 'node-header';
                
                const toggle = document.createElement('span');
                toggle.className = 'toggle';
                toggle.textContent = expanded ? '▼' : '▶';
                
                const label = document.createElement('span');
                label.textContent = node.label;

                // Expand/collapse all descendants button
                const expandAllBtn = document.createElement('span');
                expandAllBtn.className = 'expand-all';
                expandAllBtn.title = 'Expand/collapse all under this header';
                expandAllBtn.textContent = expanded ? 'Collapse all' : 'Expand all';
                
                header.appendChild(toggle);
                header.appendChild(label);
                header.appendChild(expandAllBtn);
                nodeEl.appendChild(header);
                
                const childrenEl = document.createElement('div');
                childrenEl.className = 'track-tree-children';
                if (!expanded) childrenEl.style.display = 'none';
                
                // Special handling for ClinVar node - add filter checkboxes
                if (node.label === 'ClinVar') {
                    const filterContainer = document.createElement('div');
                    filterContainer.className = 'clinvar-filter-container';
                    filterContainer.innerHTML = `
                        <div class="clinvar-filter-header">Filter by significance:</div>
                        <div class="clinvar-filter-options">
                            ${Object.entries(clinvarLabelFilter).map(([labelKey, enabled]) => {
                                const info = CLINVAR_LABELS[labelKey] || { abbrev: labelKey, color: '#666' };
                                return `
                                    <label class="clinvar-filter-option" style="border-left: 3px solid ${info.color};">
                                        <input type="checkbox" data-clinvar-label="${labelKey}" ${enabled ? 'checked' : ''}>
                                        <span>${info.abbrev}</span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                    `;
                    filterContainer.addEventListener('click', (e) => e.stopPropagation());
                    filterContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.addEventListener('change', async (e) => {
                            const labelKey = e.target.dataset.clinvarLabel;
                            clinvarLabelFilter[labelKey] = e.target.checked;
                            // Re-render if ClinVar track is selected
                            if (selectedTracks.includes('clinvar.clinvar_label_list') ||
                                selectedTracks.includes('clinvar_variants')) {
                                renderChart();
                            }
                            // Update 3D overlay if clinvar_variants is overlayed
                            if (trackOverlayState.overlayedTracks.some(t => t.trackId === 'clinvar_variants')) {
                                await updateTrackOverlaySpheres('clinvar_variants');
                            }
                        });
                    });
                    childrenEl.appendChild(filterContainer);
                }

                node.children.forEach(child => renderTreeNode(child, childrenEl, false));
                
                header.addEventListener('click', () => {
                    const isOpen = childrenEl.style.display !== 'none';
                    childrenEl.style.display = isOpen ? 'none' : 'block';
                    toggle.textContent = isOpen ? '▶' : '▼';
                    expandAllBtn.textContent = isOpen ? 'Expand all' : 'Collapse all';
                });

                const setAll = (el, expand) => {
                    el.querySelectorAll('.track-tree-children').forEach(child => {
                        child.style.display = expand ? 'block' : 'none';
                    });
                    el.querySelectorAll('.node-header .toggle').forEach(t => {
                        t.textContent = expand ? '▼' : '▶';
                    });
                };
                expandAllBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const willExpand = expandAllBtn.textContent === 'Expand all';
                    setAll(nodeEl, willExpand);
                    expandAllBtn.textContent = willExpand ? 'Collapse all' : 'Expand all';
                });
                
                nodeEl.appendChild(childrenEl);
            } else {
                const leaf = document.createElement('label');
                leaf.className = 'track-tree-leaf';
                
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.dataset.fieldId = node.fieldId;  // For syncing when track is removed via X button
                input.checked = selectedTracks.includes(node.fieldId);
                input.addEventListener('change', () => {
                    const idx = selectedTracks.indexOf(node.fieldId);
                    if (input.checked && idx < 0) {
                        selectedTracks.push(node.fieldId);
                    } else if (!input.checked && idx >= 0) {
                        selectedTracks.splice(idx, 1);
                    }
                    document.getElementById('track-count').textContent = `(${selectedTracks.length} selected)`;
                    updateSelectedTracksList();
                    renderChart();
                });
                
                const text = document.createElement('span');
                text.textContent = node.label;
                
                leaf.appendChild(input);
                leaf.appendChild(text);
                nodeEl.appendChild(leaf);
            }
            
            parentEl.appendChild(nodeEl);
        }
        
        // Update selected tracks list with drag-and-drop reordering
        function updateSelectedTracksList() {
            const container = document.getElementById('selected-tracks-container');
            const list = document.getElementById('selected-tracks-list');
            
            if (selectedTracks.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            list.innerHTML = selectedTracks.map((trackId, idx) => `
                <div class="selected-track-item" 
                     draggable="true" 
                     data-track="${trackId}"
                     data-index="${idx}">
                    <span class="drag-handle">☰</span>
                    <span class="track-name" title="${trackId}">${simplifyTrackName(trackId)}</span>
                    <button class="remove-btn" data-track="${trackId}" title="Remove">×</button>
                </div>
            `).join('');
            
            // Add drag-and-drop event listeners
            list.querySelectorAll('.selected-track-item').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedTrack = item.dataset.track;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedTrack = null;
                    // Remove all drag-over classes
                    list.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Add visual indicator
                    if (item.dataset.track !== draggedTrack) {
                        list.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                        item.classList.add('drag-over');
                    }
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over');
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    
                    if (draggedTrack && item.dataset.track !== draggedTrack) {
                        // Reorder the tracks
                        const fromIdx = selectedTracks.indexOf(draggedTrack);
                        const toIdx = selectedTracks.indexOf(item.dataset.track);
                        
                        if (fromIdx >= 0 && toIdx >= 0) {
                            // Remove from old position
                            selectedTracks.splice(fromIdx, 1);
                            // Insert at new position
                            selectedTracks.splice(toIdx, 0, draggedTrack);
                            
                            // Update the UI
                            updateSelectedTracksList();
                            renderChart();
                        }
                    }
                });
            });
            
            // Add remove button handlers
            list.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const trackId = btn.dataset.track;
                    const idx = selectedTracks.indexOf(trackId);
                    if (idx >= 0) {
                        selectedTracks.splice(idx, 1);
                        // Uncheck the checkbox in the track tree
                        const checkbox = document.querySelector(`input[data-field-id="${trackId}"]`);
                        if (checkbox) checkbox.checked = false;
                        // Update the track chip in the main list
                        const chip = document.querySelector(`.track-chip[data-track="${trackId}"]`);
                        if (chip) chip.classList.remove('selected');
                        document.getElementById('track-count').textContent = `(${selectedTracks.length} selected)`;
                        updateSelectedTracksList();
                        renderChart();
                    }
                });
            });

            // Add drop handler to the list container itself for dropping below the last item
            list.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });

            list.addEventListener('drop', (e) => {
                // Only handle drops on the list itself (not on items, which have their own handlers)
                if (e.target === list && draggedTrack) {
                    e.preventDefault();
                    const fromIdx = selectedTracks.indexOf(draggedTrack);
                    if (fromIdx >= 0) {
                        // Move to end of list
                        selectedTracks.splice(fromIdx, 1);
                        selectedTracks.push(draggedTrack);
                        updateSelectedTracksList();
                        renderChart();
                    }
                }
            });

            // Update the structure color dropdown with selected tracks
            updateStructureColorDropdown();
        }

        // Update the structure panel color dropdown with currently selected tracks
        function updateStructureColorDropdown() {
            const selectEl = document.getElementById('structure-color-select');
            console.log('[DROPDOWN] updateStructureColorDropdown called, select:', selectEl, 'selectedTracks:', selectedTracks);
            if (!selectEl) {
                console.warn('[DROPDOWN] No select element found for structure-color-select');
                return;
            }

            // Remove existing track options (keep the default option)
            const existingTrackOptions = selectEl.querySelectorAll('option[value^="track:"]');
            existingTrackOptions.forEach(opt => opt.remove());

            // Add each selected track as an option directly to the select
            selectedTracks.forEach(trackId => {
                const option = document.createElement('option');
                option.value = `track:${trackId}`;
                option.textContent = simplifyTrackName(trackId);
                selectEl.appendChild(option);
                console.log('[DROPDOWN] Added option:', option.value, option.textContent);
            });

            console.log('[DROPDOWN] Select now has', selectEl.querySelectorAll('option').length, 'options');
        }

        // Helper function to update status text
        function updateStatus(message) {
            const statusEl = document.getElementById('status-text');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }
        
        // Load data for current range
        async function loadData() {
            const [start, end] = currentRange;
            document.getElementById('status-text').textContent = 'Loading data...';
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/filtered-window?filter_id=${currentFilter}&start=${start}&end=${end}`
                );
                const data = await response.json();
                positionsData = data.positions;
                
                document.getElementById('status-text').textContent = `Loaded ${positionsData.length} positions`;
                renderChart();
                
                // Update gene display
                await updateGeneDisplay();
            } catch (e) {
                console.error('Failed to load data:', e);
                document.getElementById('status-text').textContent = 'Error loading data';
            }
        }
        
        // Store current zoom transform globally
        let currentZoomTransform = d3.zoomIdentity;
        
        // Canvas rendering class for high-performance track visualization
        class TrackCanvas {
            constructor(container, width, height, trackId) {
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas = document.createElement('canvas');
                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                this.canvas.style.display = 'block';
                this.canvas.style.backgroundColor = '#E4E0DD'; // Match chart background
                
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.ctx.scale(dpr, dpr);
                
                this.trackId = trackId;
                this.width = width;
                this.height = height;
                
                container.appendChild(this.canvas);
            }
            
            clear() {
                // Fill with background color instead of clearing to transparent
                this.ctx.fillStyle = '#E4E0DD';
                this.ctx.fillRect(0, 0, this.width, this.height);
            }
            
            drawBars(positionsData, values, xScale, colorScale, barWidth) {
                this.clear();
                
                positionsData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const value = values[i];
                    
                    this.ctx.fillStyle = colorScale(value);
                    // Add 0.5px to width to eliminate gaps between bars
                    this.ctx.fillRect(
                        x, 
                        5, 
                        Math.ceil(Math.max(1, barWidth)) + 0.5, 
                        this.height - 15
                    );
                });
            }
            
            // Draw ClinVar stacked bars
            drawClinVarStacked(positionsData, xScale, barWidth) {
                this.clear();
                const barHeight = this.height - 15;
                
                positionsData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const labels = d['clinvar.clinvar_label_list'];
                    
                    if (!labels || !Array.isArray(labels) || labels.length === 0) {
                        // No ClinVar data - draw gray bar
                        this.ctx.fillStyle = '#555555';
                        this.ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }
                    
                    // Filter labels based on clinvarLabelFilter
                    const filteredLabels = labels.filter(label => clinvarLabelPassesFilter(label));
                    
                    if (filteredLabels.length === 0) {
                        // No labels pass filter - draw gray bar
                        this.ctx.fillStyle = '#555555';
                        this.ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }
                    
                    // Count unique labels and sort by priority
                    const labelCounts = {};
                    filteredLabels.forEach(label => {
                        labelCounts[label] = (labelCounts[label] || 0) + 1;
                    });
                    
                    // Sort labels by severity (pathogenic first)
                    const sortedLabels = Object.keys(labelCounts).sort((a, b) => {
                        const priorityOrder = ['Pathogenic', 'Likely_pathogenic', 'Pathogenic/Likely_pathogenic',
                            'Uncertain_significance', 'Conflicting', 'Likely_benign', 'Benign', 'Benign/Likely_benign'];
                        const aIdx = priorityOrder.findIndex(p => a.includes(p));
                        const bIdx = priorityOrder.findIndex(p => b.includes(p));
                        return (aIdx === -1 ? 999 : aIdx) - (bIdx === -1 ? 999 : bIdx);
                    });
                    
                    // Draw stacked segments
                    const totalLabels = sortedLabels.length;
                    const segmentHeight = barHeight / totalLabels;
                    
                    sortedLabels.forEach((label, idx) => {
                        this.ctx.fillStyle = getClinVarColor(label);
                        this.ctx.fillRect(
                            x, 
                            5 + idx * segmentHeight, 
                            Math.ceil(Math.max(1, barWidth)) + 0.5, 
                            segmentHeight + 0.5  // Small overlap to prevent gaps
                        );
                    });
                });
            }
            
            // Draw domain presence/absence with new array format
            drawDomains(positionsData, xScale, barWidth) {
                this.clear();
                const barHeight = this.height - 15;

                positionsData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const domains = d['domains'];

                    // Check if domains array exists and has entries
                    const hasDomain = domains && Array.isArray(domains) && domains.length > 0;

                    this.ctx.fillStyle = hasDomain ? '#00b894' : '#555555';
                    this.ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                });
            }

            // Draw single-value bars with height proportional to value (like constraint predictions but single value)
            drawHeightBars(positionsData, values, xScale, colorScale, barWidth, yMax, yMin = 0) {
                this.clear();
                const ctx = this.ctx;
                const barHeight = this.height - 15;
                const topPadding = 5;

                // Check if we need center-baseline drawing (e.g., for -1 to 1 scale)
                const isCentered = yMin < 0;

                positionsData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const value = values[i];

                    if (value === null || value === undefined || isNaN(value)) {
                        return;
                    }

                    if (isCentered) {
                        // Center-baseline drawing for -1 to 1 scale
                        // 0 is at the center, positive goes up, negative goes down
                        const centerY = topPadding + barHeight / 2;
                        const halfHeight = barHeight / 2;

                        if (value === 0) {
                            // Draw a thin line at center for neutral
                            ctx.fillStyle = colorScale(value);
                            ctx.fillRect(x, centerY - 1, Math.ceil(Math.max(1, barWidth)) + 0.5, 2);
                        } else if (value > 0) {
                            // Positive (constrained): draw upward from center
                            const normalizedValue = Math.min(value / yMax, 1);
                            const segmentHeight = normalizedValue * halfHeight;
                            ctx.fillStyle = colorScale(value);
                            ctx.fillRect(x, centerY - segmentHeight, Math.ceil(Math.max(1, barWidth)) + 0.5, segmentHeight);
                        } else {
                            // Negative (positive selection): draw downward from center
                            const normalizedValue = Math.min(Math.abs(value) / Math.abs(yMin), 1);
                            const segmentHeight = normalizedValue * halfHeight;
                            ctx.fillStyle = colorScale(value);
                            ctx.fillRect(x, centerY, Math.ceil(Math.max(1, barWidth)) + 0.5, segmentHeight);
                        }
                    } else {
                        // Standard bottom-up drawing
                        if (value === 0) return;

                        const normalizedValue = Math.min(value / yMax, 1);
                        const segmentHeight = normalizedValue * barHeight;
                        const segmentTop = topPadding + barHeight - segmentHeight;

                        ctx.fillStyle = colorScale(value);
                        ctx.fillRect(x, segmentTop, Math.ceil(Math.max(1, barWidth)) + 0.5, segmentHeight);
                    }
                });
            }

            // Draw constraint prediction stacked bars
            drawConstraintStacked(variantData, xScale, colorScale, barWidth) {
                this.clear();
                const ctx = this.ctx;
                const barHeight = this.height - 15;

                variantData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);

                    if (!d.variants || d.variants.length === 0) {
                        // No variant data - draw gray bar
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }

                    // Variants are already sorted by pred value (lowest to highest)
                    const variants = d.variants;

                    // Scale factor: map pred values to pixel height
                    // Max expected total ~= 3.0 (3 variants * ~1.0 each)
                    const maxDisplay = 3.0;
                    const scaleFactor = barHeight / maxDisplay;

                    let currentY = 5 + barHeight;  // Start from bottom

                    variants.forEach(variant => {
                        const segmentHeight = variant.pred * scaleFactor;
                        const segmentTop = currentY - segmentHeight;

                        // Fill segment with pathogenicity color based on individual pred
                        ctx.fillStyle = colorScale(variant.pred);
                        ctx.fillRect(x, segmentTop, Math.ceil(Math.max(1, barWidth)) + 0.5, segmentHeight);

                        // Draw only the top divider line between variants (not full border)
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(x, segmentTop);
                        ctx.lineTo(x + Math.ceil(Math.max(1, barWidth)) + 0.5, segmentTop);
                        ctx.stroke();

                        currentY = segmentTop;
                    });
                });
            }

            // Draw dbNSFP stacked bars (AlphaMissense, ESM1b)
            drawDbNSFPStacked(variantData, xScale, colorScale, barWidth, scoreRange) {
                this.clear();
                const ctx = this.ctx;
                const barHeight = this.height - 15;
                const [minScore, maxScore] = scoreRange;

                // Normalize score to 0-1 range for color mapping
                const normalizeScore = (score) => {
                    if (minScore === maxScore) return 0.5;
                    return (score - minScore) / (maxScore - minScore);
                };

                variantData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);

                    if (!d.variants || d.variants.length === 0) {
                        // No variant data - draw gray bar
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }

                    // Variants are already sorted by score value (lowest to highest)
                    const variants = d.variants;

                    // Scale factor: map scores to pixel height
                    // Max expected ~3 variants, each gets equal height
                    const maxDisplay = 3.0;
                    const scaleFactor = barHeight / maxDisplay;

                    let currentY = 5 + barHeight;  // Start from bottom

                    variants.forEach(variant => {
                        // Each variant gets a fixed height segment
                        const segmentHeight = scaleFactor;
                        const segmentTop = currentY - segmentHeight;

                        // Color based on normalized score
                        const normalizedScore = normalizeScore(variant.score);
                        ctx.fillStyle = colorScale(normalizedScore);
                        ctx.fillRect(x, segmentTop, Math.ceil(Math.max(1, barWidth)) + 0.5, segmentHeight);

                        // Draw divider line between variants
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(x, segmentTop);
                        ctx.lineTo(x + Math.ceil(Math.max(1, barWidth)) + 0.5, segmentTop);
                        ctx.stroke();

                        currentY = segmentTop;
                    });
                });
            }

            // Draw variant frequency ellipses (gnomAD style)
            drawVariantFrequency(variantData, xScale, barWidth, trackId) {
                this.clear();
                const ctx = this.ctx;
                const centerY = this.height / 2;
                const color = COHORT_COLORS[trackId] || '#666666';

                variantData.forEach((d, i) => {
                    const variants = d.variants || [];
                    const x = xScale(d.filtered_idx);

                    if (variants.length === 0) {
                        // No variants - draw thin gray line
                        ctx.fillStyle = '#cccccc';
                        ctx.fillRect(x, centerY - 1, Math.ceil(Math.max(1, barWidth)) + 0.5, 2);
                        return;
                    }

                    variants.forEach((variant, vIdx) => {
                        if (!variant || variant.af === null || variant.af === undefined) return;

                        // Check filter status
                        const isFiltered = variant.filters && variant.filters.length > 0;
                        if (isFiltered && !showFilteredVariants) return;

                        // Calculate ellipse size from AF (log scale)
                        // AF range: 1e-6 to 1, map to radius 2-15
                        const af = Math.max(variant.af, 1e-7);
                        const logAf = Math.log10(af);  // -7 to 0
                        const normalizedAf = (logAf + 7) / 7;  // 0 to 1
                        const ry = 2 + normalizedAf * 13;  // 2 to 15
                        const rx = Math.max(1.5, barWidth / 3);

                        // Offset multiple variants vertically
                        const offsetY = (vIdx - (variants.length - 1) / 2) * (ry + 2);

                        // Draw ellipse
                        ctx.beginPath();
                        ctx.ellipse(x + barWidth / 2, centerY + offsetY, rx, ry, 0, 0, 2 * Math.PI);

                        if (isFiltered) {
                            // Filtered: hollow with dashed stroke
                            ctx.strokeStyle = color;
                            ctx.setLineDash([2, 2]);
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                            ctx.setLineDash([]);
                        } else {
                            // PASS: filled solid
                            ctx.fillStyle = color;
                            ctx.fill();
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    });
                });
            }

            // Draw ClinVar variants with significance colors
            drawClinVarVariants(variantData, xScale, barWidth) {
                this.clear();
                const ctx = this.ctx;
                const barHeight = this.height - 15;
                const centerY = this.height / 2;

                variantData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const variants = d.variants || [];

                    if (variants.length === 0) {
                        // No ClinVar data - draw gray bar
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }

                    // Filter variants by current significance filter
                    const filteredVariants = variants.filter(v => {
                        return clinvarLabelPassesFilter(v.significance || 'other');
                    });

                    if (filteredVariants.length === 0) {
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(x, 5, Math.ceil(Math.max(1, barWidth)) + 0.5, barHeight);
                        return;
                    }

                    // Draw each variant as a colored symbol
                    const symbolSize = Math.max(4, barWidth * 0.8);
                    filteredVariants.forEach((variant, vIdx) => {
                        const offsetY = (vIdx - (filteredVariants.length - 1) / 2) * (symbolSize + 2);
                        const cx = x + barWidth / 2;
                        const cy = centerY + offsetY;

                        // Get color from significance
                        const color = getClinVarColor(variant.significance || 'other');
                        ctx.fillStyle = color;
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 0.5;

                        // Draw shape based on molecular consequence
                        const csq = variant.mol_csq || '';
                        if (csq.includes('frameshift') || csq.includes('stop_gained') || csq.includes('splice_acceptor') || csq.includes('splice_donor')) {
                            // pLoF: Cross/X
                            const half = symbolSize / 2;
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = color;
                            ctx.beginPath();
                            ctx.moveTo(cx - half, cy - half);
                            ctx.lineTo(cx + half, cy + half);
                            ctx.moveTo(cx + half, cy - half);
                            ctx.lineTo(cx - half, cy + half);
                            ctx.stroke();
                            ctx.lineWidth = 0.5;
                            ctx.strokeStyle = '#333';
                        } else if (csq.includes('missense') || csq.includes('inframe')) {
                            // Missense: Triangle
                            const half = symbolSize / 2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - half);
                            ctx.lineTo(cx + half, cy + half);
                            ctx.lineTo(cx - half, cy + half);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        } else if (csq.includes('splice_region')) {
                            // Splice region: Diamond
                            const half = symbolSize / 2;
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - half);
                            ctx.lineTo(cx + half, cy);
                            ctx.lineTo(cx, cy + half);
                            ctx.lineTo(cx - half, cy);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        } else {
                            // Other: Circle
                            ctx.beginPath();
                            ctx.arc(cx, cy, symbolSize / 2, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                });
            }

            // Draw coverage area chart (gnomAD style)
            drawCoverageArea(positionsData, values, xScale, barWidth, trackId) {
                this.clear();
                const ctx = this.ctx;
                const barHeight = this.height - 15;
                const topPadding = 5;

                // Determine color based on exome vs genome
                const isExome = trackId.includes('exomes');
                const fillColor = isExome ? COVERAGE_COLORS.exome : COVERAGE_COLORS.genome;
                const strokeColor = isExome ? 'rgba(66, 133, 244, 1)' : 'rgba(52, 168, 83, 1)';

                // For coverage tracks, values are fractions (0-1) or raw coverage values
                // Determine max value for scaling
                const isOverTrack = trackId.includes('over_');
                const yMax = isOverTrack ? 1.0 : Math.max(...values.filter(v => v !== null && !isNaN(v)), 100);

                // Build path for area chart
                ctx.beginPath();
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 1;

                let started = false;
                let lastX = 0;
                let lastY = topPadding + barHeight;

                positionsData.forEach((d, i) => {
                    const x = xScale(d.filtered_idx);
                    const value = values[i];

                    if (value === null || value === undefined || isNaN(value)) {
                        return;
                    }

                    // Calculate y position (0 at bottom, max at top)
                    const normalizedValue = Math.min(value / yMax, 1);
                    const y = topPadding + barHeight - (normalizedValue * barHeight);

                    if (!started) {
                        ctx.moveTo(x, topPadding + barHeight);  // Start at baseline
                        ctx.lineTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }

                    lastX = x + barWidth;
                    lastY = y;
                });

                // Close the path back to baseline
                if (started) {
                    ctx.lineTo(lastX, topPadding + barHeight);
                    ctx.closePath();
                    ctx.fill();

                    // Draw top stroke only
                    ctx.beginPath();
                    let strokeStarted = false;
                    positionsData.forEach((d, i) => {
                        const x = xScale(d.filtered_idx);
                        const value = values[i];
                        if (value === null || value === undefined || isNaN(value)) return;
                        const normalizedValue = Math.min(value / yMax, 1);
                        const y = topPadding + barHeight - (normalizedValue * barHeight);
                        if (!strokeStarted) {
                            ctx.moveTo(x, y);
                            strokeStarted = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                }

                // Draw y-axis baseline
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, topPadding + barHeight);
                ctx.lineTo(this.width, topPadding + barHeight);
                ctx.stroke();
            }
        }

        // Main render function with zoom support (Canvas-based)
        function renderChart() {
            const container = document.getElementById('chart-container');
            container.innerHTML = '';
            
            if (selectedTracks.length === 0) {
                container.innerHTML = '<div class="loading" style="animation:none;">Select tracks from the left panel</div>';
                return;
            }
            
            if (positionsData.length === 0) {
                container.innerHTML = '<div class="loading" style="animation:none;">No data available</div>';
                return;
            }
            
            const tracks = [...selectedTracks];  // Copy the array to maintain order
            const width = container.clientWidth - MARGIN.left - MARGIN.right;
            const height = tracks.length * TRACK_HEIGHT;
            const totalHeight = height + MARGIN.top + MARGIN.bottom;
            
            // Create canvas container for data visualization
            const canvasContainer = document.createElement('div');
            canvasContainer.id = 'canvas-container';
            canvasContainer.style.position = 'relative';
            canvasContainer.style.width = (width + MARGIN.left + MARGIN.right) + 'px';
            canvasContainer.style.height = totalHeight + 'px';
            container.appendChild(canvasContainer);
            
            // Create SVG overlay for axes, labels, crosshair, brush
            const svg = d3.select(canvasContainer)
                .append('svg')
                .attr('id', 'overlay-svg')
                .attr('width', width + MARGIN.left + MARGIN.right)
                .attr('height', totalHeight)
                .style('position', 'absolute')
                .style('top', '0')
                .style('left', '0')
                .style('z-index', '10');
            
            const g = svg.append('g')
                .attr('transform', `translate(${MARGIN.left},${MARGIN.top})`);

            // Add clipPath to constrain highlight rect within plot area
            const clipId = 'plot-clip-' + Date.now();
            svg.append('defs')
                .append('clipPath')
                .attr('id', clipId)
                .append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', height);

            // Add invisible interaction rect for zoom/pan that also triggers tooltips
            const interactionRect = g.append('rect')
                .attr('class', 'interaction-rect')
                .attr('width', width)
                .attr('height', height)
                .attr('fill', 'transparent')
                .style('cursor', 'grab');
            
            // X Scale (filtered index)
            const xExtent = d3.extent(positionsData, d => d.filtered_idx);
            const xScale = d3.scaleLinear()
                .domain(xExtent)
                .range([0, width]);

            // Store scale and width globally for crosshair/highlight sync
            trackXScale = xScale.copy();
            trackPlotWidth = width;

            // Store original scale for zoom reset
            const xScaleOriginal = xScale.copy();
            
            // Apply existing zoom transform
            const xScaleZoomed = currentZoomTransform.rescaleX(xScale);
            
            // Create canvas tracks container
            const canvasTracksContainer = document.createElement('div');
            canvasTracksContainer.style.position = 'absolute';
            canvasTracksContainer.style.left = MARGIN.left + 'px';
            canvasTracksContainer.style.top = MARGIN.top + 'px';
            canvasTracksContainer.style.width = width + 'px';
            canvasTracksContainer.style.height = height + 'px';
            canvasTracksContainer.style.zIndex = '5';
            canvasContainer.appendChild(canvasTracksContainer);
            
            // Store track data for zoom updates
            const trackCanvases = [];
            const trackColorScales = [];
            const trackValues = [];
            
            // Draw each track with Canvas
            tracks.forEach((trackId, i) => {
              try {
                // Check track types
                const isDomain = isDomainTrack(trackId);
                const isClinVarStacked = isClinVarStackedTrack(trackId);
                const isClinVarVariants = isClinVarVariantsTrack(trackId);
                const isVariantFrequency = isVariantFrequencyTrack(trackId);
                const isCoverage = isCoverageTrack(trackId);
                const isClinVar = isClinVarTrack(trackId);
                const isTraining = isTrainingTrack(trackId);
                const isConstraintStacked = isConstraintStackedTrack(trackId);
                const isDbNSFPStacked = isDbNSFPStackedTrack(trackId);

                // Get values for this track
                let values;
                if (isConstraintStacked) {
                    // Constraint tracks: extract variant data from positionsData
                    // Apply consequence filter if variant_consequences data is available
                    values = positionsData.map(d => {
                        const variantArray = d[trackId];
                        if (!variantArray || !Array.isArray(variantArray)) {
                            return { filtered_idx: d.filtered_idx, variants: [] };
                        }

                        // Extract variants from the array, filtering by consequence
                        // Using new struct format: {alt, pred, n_pred}
                        const variants = [];
                        for (const v of variantArray) {
                            if (v && v.alt && v.pred !== null && v.pred !== undefined) {
                                const allele = v.alt;
                                const pred = v.pred;

                                // Look up consequence for this allele
                                const csq = getConsequenceForAllele(d, allele);

                                // Check if this variant passes the consequence filter
                                if (!consequencePassesFilter(csq)) {
                                    continue;  // Skip variants that don't pass filter
                                }

                                variants.push({
                                    allele: allele,
                                    pred: pred,
                                    consequence: csq  // Store consequence for tooltip/coloring
                                });
                            }
                        }

                        // Sort by pred value (lowest to highest)
                        variants.sort((a, b) => a.pred - b.pred);

                        return {
                            filtered_idx: d.filtered_idx,
                            variants: variants
                        };
                    });
                } else if (isDbNSFPStacked) {
                    // dbNSFP stacked tracks: extract variant data with score and percentile
                    // Using new struct format: {alt, score, percentile}
                    values = positionsData.map(d => {
                        const variantArray = d[trackId];
                        if (!variantArray || !Array.isArray(variantArray)) {
                            return { filtered_idx: d.filtered_idx, variants: [] };
                        }

                        const variants = [];
                        for (const v of variantArray) {
                            if (v && v.alt && v.score !== null && v.score !== undefined) {
                                variants.push({
                                    allele: v.alt,
                                    score: v.score,
                                    percentile: v.percentile || null
                                });
                            }
                        }

                        // Sort by score value (lowest to highest)
                        variants.sort((a, b) => a.score - b.score);

                        return {
                            filtered_idx: d.filtered_idx,
                            variants: variants
                        };
                    });
                } else if (isClinVarVariants) {
                    // ClinVar variants track: data comes from API with variants array
                    // Format: {filtered_idx, variants: [{alt, significance, status, mol_csq, variation_id}, ...]}
                    values = positionsData.map(d => {
                        const variantArray = d[trackId];
                        if (!variantArray || !Array.isArray(variantArray)) {
                            return { filtered_idx: d.filtered_idx, variants: [] };
                        }
                        return {
                            filtered_idx: d.filtered_idx,
                            variants: variantArray
                        };
                    });
                } else if (isVariantFrequency) {
                    // Variant frequency track: data comes from API with variants array
                    // Format: {filtered_idx, variants: [{alt, af, ac, an, filters}, ...]}
                    values = positionsData.map(d => {
                        const variantArray = d[trackId];
                        if (!variantArray || !Array.isArray(variantArray)) {
                            return { filtered_idx: d.filtered_idx, variants: [] };
                        }
                        return {
                            filtered_idx: d.filtered_idx,
                            variants: variantArray
                        };
                    });
                } else {
                    // Get effective field ID (percentile version if available and mode is on)
                    const effectiveFieldId = getEffectiveFieldId(trackId);
                    const usingPercentile = effectiveFieldId !== trackId;

                    values = positionsData.map(d => {
                        if (isDomain) {
                            // Domain track: 1 if domain present, 0 if absent (new array format)
                            const domains = d['domains'];
                            return (domains && Array.isArray(domains) && domains.length > 0) ? 1 : 0;
                        }
                        if (isClinVarStacked) {
                            // ClinVar stacked: return the count of labels
                            const labels = d['clinvar.clinvar_label_list'];
                            return (labels && Array.isArray(labels)) ? labels.length : 0;
                        }
                        const val = d[effectiveFieldId];
                        return (val !== null && val !== undefined && !isNaN(val)) ? val : 0;
                    });
                }
                trackValues.push(values);

                const isOE = isOETrack(trackId);
                const isCounts = isCountsTrack(trackId);
                const isObserved = isObservedTrack(trackId);
                const isComparator = COMPARATOR_TRACKS.has(trackId);
                const isPercTrack = isPercentileTrack(trackId);

                // Transform O/E values for non-percentile tracks: constraint score = 1 - O/E
                // This gives: 1 = constrained (O/E≈0), 0 = neutral (O/E=1), -1 = positive selection (O/E>1)
                const isRawOE = isOE && !isPercTrack;
                if (isRawOE) {
                    values = values.map(v => {
                        if (v === null || v === undefined || isNaN(v)) return null;
                        return 1 - v;  // Transform: constraint score = 1 - O/E
                    });
                }

                // For raw O/E (now transformed), scale is -1 to 1
                // Percentile values are 0-1, so yMax should be 1; otherwise use normal logic
                const yMax = isPercTrack ? 1 : ((isDomain || isClinVarStacked) ? 1 : (isRawOE ? 1 : d3.max(values) || 1));
                const yMin = isRawOE ? -1 : 0;
                const isFlipped = flippedTracks.has(trackId);

                // Color scale
                let colorScale;
                let legendType = 'continuous'; // continuous | discrete | domain | clinvar | constraint_stacked
                let legendBins = [];
                if (isConstraintStacked) {
                    // Constraint tracks: pathogenicity gradient
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, 0.3, 0.7, 1.0])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                    legendType = 'constraint_stacked';
                } else if (isDbNSFPStacked) {
                    // dbNSFP stacked: same pathogenicity gradient as constraint
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, 0.3, 0.7, 1.0])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                    legendType = 'dbnsfp_stacked';
                } else if (isClinVarVariants) {
                    // ClinVar variants: colors determined by significance (in drawing method)
                    colorScale = (val) => '#e74c3c';  // Default red, actual color per-variant
                    legendType = 'clinvar_variants';
                } else if (isVariantFrequency) {
                    // Variant frequency: colors by cohort (in drawing method)
                    colorScale = (val) => COHORT_COLORS[trackId] || '#666666';
                    legendType = 'variant_frequency';
                } else if (isDomain) {
                    // Domain track: green for present, dark gray for absent
                    colorScale = (val) => val > 0 ? '#00b894' : '#555555';
                    legendType = 'domain';
                } else if (isClinVarStacked) {
                    // ClinVar stacked (legacy): special handling (colors determined by labels)
                    colorScale = (val) => val > 0 ? '#e74c3c' : '#555555';
                    legendType = 'clinvar';
                } else if (isTraining || isCounts || isObserved || isComparator || trackId.startsWith('dbnsfp.') || isRGCSummaryTrack(trackId)) {
                    // Training, counts, observed, RGC summary, comparators, and dbNSFP use same gradient as Constraint
                    // High value = red (pathogenic/constrained), low value = green (benign/tolerant)
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, yMax * 0.3, yMax * 0.7, yMax])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                } else if (isRawOE) {
                    // Raw O/E (transformed to constraint score): scale is -1 to 1
                    // -1 = positive selection (green), 0 = neutral (yellow), 1 = constrained (red)
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([-1, 0, 0.5, 1])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                } else if (isOE) {
                    // Percentile O/E: 0-1 scale like other percentiles
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, yMax * 0.3, yMax * 0.7, yMax])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                } else if (trackId.toLowerCase().includes('vir')) {
                    // VIR: same gradient as constraint (green = low, red = high)
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, yMax * 0.3, yMax * 0.7, yMax])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                } else {
                    // Default: same gradient as constraint
                    const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                    colorScale = d3.scaleLinear()
                        .domain([0, yMax * 0.3, yMax * 0.7, yMax])
                        .range(isFlipped ? baseRange.slice().reverse() : baseRange)
                        .clamp(true);
                }
                trackColorScales.push(colorScale);
                
                // Create canvas wrapper for this track
                const wrapper = document.createElement('div');
                wrapper.style.position = 'absolute';
                wrapper.style.left = '0px';
                wrapper.style.top = (i * TRACK_HEIGHT) + 'px';
                wrapper.style.width = width + 'px';
                wrapper.style.height = TRACK_HEIGHT + 'px';
                
                // Create canvas for this track
                const trackCanvas = new TrackCanvas(wrapper, width, TRACK_HEIGHT, trackId);
                
                // Draw bars on canvas
                const barWidth = width / positionsData.length;
                
                // Determine if this track uses height-based bars (like constraint predictions)
                const usesHeightBars = isTraining || isCounts || isObserved || isComparator || isOE || trackId.startsWith('dbnsfp.') || isRGCSummaryTrack(trackId);

                console.log(`[TRACK] ${trackId}: isCounts=${isCounts}, isObserved=${isObserved}, isComparator=${isComparator}, isRGCSummary=${isRGCSummaryTrack(trackId)}, usesHeightBars=${usesHeightBars}`);

                // Use specialized drawing method based on track type
                if (isConstraintStacked) {
                    trackCanvas.drawConstraintStacked(
                        values,
                        xScaleZoomed,
                        colorScale,
                        barWidth * currentZoomTransform.k
                    );
                } else if (isDbNSFPStacked) {
                    // Score range depends on track type
                    const scoreRange = trackId === 'AlphaMissense_stacked' ? [0, 1] : [-10, 5];
                    trackCanvas.drawDbNSFPStacked(
                        values,
                        xScaleZoomed,
                        colorScale,
                        barWidth * currentZoomTransform.k,
                        scoreRange
                    );
                } else if (isClinVarStacked) {
                    trackCanvas.drawClinVarStacked(
                        positionsData,
                        xScaleZoomed,
                        barWidth * currentZoomTransform.k
                    );
                } else if (isClinVarVariants) {
                    trackCanvas.drawClinVarVariants(
                        values,
                        xScaleZoomed,
                        barWidth * currentZoomTransform.k
                    );
                } else if (isVariantFrequency) {
                    trackCanvas.drawVariantFrequency(
                        values,
                        xScaleZoomed,
                        barWidth * currentZoomTransform.k,
                        trackId
                    );
                } else if (isCoverage) {
                    trackCanvas.drawCoverageArea(
                        positionsData,
                        values,
                        xScaleZoomed,
                        barWidth * currentZoomTransform.k,
                        trackId
                    );
                } else if (isDomain && trackId === 'domains') {
                    trackCanvas.drawDomains(
                        positionsData,
                        xScaleZoomed,
                        barWidth * currentZoomTransform.k
                    );
                } else if (usesHeightBars) {
                    trackCanvas.drawHeightBars(
                        positionsData,
                        values,
                        xScaleZoomed,
                        colorScale,
                        barWidth * currentZoomTransform.k,
                        yMax,
                        yMin
                    );
                } else {
                    trackCanvas.drawBars(
                        positionsData,
                        values,
                        xScaleZoomed,
                        colorScale,
                        barWidth * currentZoomTransform.k
                    );
                }
                
                canvasTracksContainer.appendChild(wrapper);
                trackCanvases.push({
                    canvas: trackCanvas,
                    trackId,
                    values,
                    colorScale,
                    isDomain,
                    isClinVarStacked,
                    isClinVarVariants,
                    isVariantFrequency,
                    isCoverage,
                    isConstraintStacked,
                    isDbNSFPStacked,
                    usesHeightBars,
                    legendType,
                    legendBins,
                    yMax,
                    yMin
                });
                
                // Track label (outside clip area) - simplifyTrackName already adds % for percentile tracks
                const trackLabel = simplifyTrackName(trackId);
                g.append('text')
                    .attr('x', -10)
                    .attr('y', i * TRACK_HEIGHT + TRACK_HEIGHT / 2)
                    .attr('text-anchor', 'end')
                    .attr('dominant-baseline', 'middle')
                    .attr('class', 'track-label')
                    .text(trackLabel);
                
                // Mini colorbar/legend (outside clip area)
                const colorbarWidth = 15;
                const colorbarHeight = TRACK_HEIGHT - 20;
                const colorbarX = width + 10;
                
                const colorbarG = g.append('g')
                    .attr('transform', `translate(${colorbarX}, ${i * TRACK_HEIGHT + 5})`);
                
                if (legendType === 'domain') {
                    // Domain track: show simple legend (Present/Absent)
                    const legendHeight = colorbarHeight / 2;
                    
                    // Present box (green)
                    colorbarG.append('rect')
                        .attr('width', colorbarWidth)
                        .attr('height', legendHeight - 2)
                        .attr('fill', '#00b894');
                    
                    colorbarG.append('text')
                        .attr('x', colorbarWidth + 3)
                        .attr('y', legendHeight / 2)
                        .attr('font-size', '0.5rem')
                        .attr('fill', '#888')
                        .attr('dominant-baseline', 'middle')
                        .text('✓');
                    
                    // Absent box
                    colorbarG.append('rect')
                        .attr('y', legendHeight)
                        .attr('width', colorbarWidth)
                        .attr('height', legendHeight - 2)
                        .attr('fill', '#555555');
                    
                    colorbarG.append('text')
                        .attr('x', colorbarWidth + 3)
                        .attr('y', legendHeight + legendHeight / 2)
                        .attr('font-size', '0.5rem')
                        .attr('fill', '#888')
                        .attr('dominant-baseline', 'middle')
                        .text('—');
                } else if (legendType === 'clinvar') {
                    // ClinVar legend: show key labels
                    const clinvarLabels = ['P', 'LP', 'VUS', 'LB', 'B'];
                    const clinvarColors = ['#d62728', '#ff7f0e', '#bcbd22', '#2ca02c', '#1f77b4'];
                    const boxH = Math.max(8, colorbarHeight / clinvarLabels.length);

                    clinvarLabels.forEach((label, idx) => {
                        const y = idx * boxH;
                        colorbarG.append('rect')
                            .attr('y', y)
                            .attr('width', colorbarWidth)
                            .attr('height', boxH - 1)
                            .attr('fill', clinvarColors[idx]);

                        colorbarG.append('text')
                            .attr('x', colorbarWidth + 3)
                            .attr('y', y + (boxH / 2))
                            .attr('font-size', '0.5rem')
                            .attr('fill', '#888')
                            .attr('dominant-baseline', 'middle')
                            .text(label);
                    });
                } else if (legendType === 'constraint_stacked') {
                    // Constraint stacked: pathogenicity gradient
                    const gradientId = `constraint-gradient-${i}-${Date.now()}`;
                    const gradient = svg.append('defs')
                        .append('linearGradient')
                        .attr('id', gradientId)
                        .attr('x1', '0%').attr('y1', '100%')
                        .attr('x2', '0%').attr('y2', '0%');

                    // Create gradient stops matching the color scale
                    const stops = [
                        { offset: 0, value: 0.0, color: '#488b49' },    // Green - benign
                        { offset: 0.3, value: 0.3, color: '#dcdc04' },  // Yellow - uncertain
                        { offset: 0.7, value: 0.7, color: '#e67e22' },  // Orange - moderate
                        { offset: 1.0, value: 1.0, color: '#cc0000' }   // Red - pathogenic
                    ];

                    stops.forEach(stop => {
                        gradient.append('stop')
                            .attr('offset', `${stop.offset * 100}%`)
                            .attr('stop-color', stop.color);
                    });

                    // Draw gradient bar
                    colorbarG.append('rect')
                        .attr('width', colorbarWidth)
                        .attr('height', colorbarHeight)
                        .attr('fill', `url(#${gradientId})`);

                    // Add axis ticks
                    const constraintScale = d3.scaleLinear()
                        .domain([0, 1.0])
                        .range([colorbarHeight, 0]);

                    const constraintAxis = d3.axisRight(constraintScale)
                        .ticks(5)
                        .tickFormat(d3.format('.1f'));

                    colorbarG.append('g')
                        .attr('transform', `translate(${colorbarWidth}, 0)`)
                        .call(constraintAxis)
                        .call(g => {
                            g.select('.domain').remove();
                            g.selectAll('.tick line').attr('x2', 3).attr('stroke', '#777');
                            g.selectAll('.tick text')
                                .attr('fill', '#888')
                                .attr('font-size', '0.6rem');
                        });
                } else if (legendType === 'dbnsfp_stacked') {
                    // dbNSFP stacked: pathogenicity gradient (same as constraint)
                    const gradientId = `dbnsfp-gradient-${i}-${Date.now()}`;
                    const gradient = svg.append('defs')
                        .append('linearGradient')
                        .attr('id', gradientId)
                        .attr('x1', '0%').attr('y1', '100%')
                        .attr('x2', '0%').attr('y2', '0%');

                    // Create gradient stops matching the color scale
                    const stops = [
                        { offset: 0, value: 0.0, color: '#488b49' },    // Green - benign
                        { offset: 0.3, value: 0.3, color: '#dcdc04' },  // Yellow - uncertain
                        { offset: 0.7, value: 0.7, color: '#e67e22' },  // Orange - moderate
                        { offset: 1.0, value: 1.0, color: '#cc0000' }   // Red - pathogenic
                    ];

                    stops.forEach(stop => {
                        gradient.append('stop')
                            .attr('offset', `${stop.offset * 100}%`)
                            .attr('stop-color', stop.color);
                    });

                    // Draw gradient bar
                    colorbarG.append('rect')
                        .attr('width', colorbarWidth)
                        .attr('height', colorbarHeight)
                        .attr('fill', `url(#${gradientId})`);

                    // Add axis ticks
                    const dbnsfpScale = d3.scaleLinear()
                        .domain([0, 1.0])
                        .range([colorbarHeight, 0]);

                    const dbnsfpAxis = d3.axisRight(dbnsfpScale)
                        .ticks(5)
                        .tickFormat(d3.format('.1f'));

                    colorbarG.append('g')
                        .attr('transform', `translate(${colorbarWidth}, 0)`)
                        .call(dbnsfpAxis)
                        .call(g => {
                            g.select('.domain').remove();
                            g.selectAll('.tick line').attr('x2', 3).attr('stroke', '#777');
                            g.selectAll('.tick text')
                                .attr('fill', '#888')
                                .attr('font-size', '0.6rem');
                        });
                } else if (legendType === 'discrete') {
                    // Discrete legend for counts/observed
                    const boxH = Math.max(12, colorbarHeight / (legendBins.length + 1));
                    const palette = colorScale.range();
                    legendBins.forEach((b, idx) => {
                        const y = idx * boxH;
                        colorbarG.append('rect')
                            .attr('y', y)
                            .attr('width', colorbarWidth)
                            .attr('height', boxH - 2)
                            .attr('fill', palette[idx]);
                        
                        colorbarG.append('text')
                            .attr('x', colorbarWidth + 3)
                            .attr('y', y + (boxH / 2))
                            .attr('font-size', '0.6rem')
                            .attr('fill', '#888')
                            .attr('dominant-baseline', 'middle')
                            .text(`${legendBins[idx]}`);
                    });
                } else {
                    // Regular track: gradient colorbar
                    // Use yMin for raw O/E tracks (yMin = -1), otherwise 0
                    const effectiveYMin = yMin !== undefined ? yMin : 0;
                    const colorbarScale = d3.scaleLinear()
                        .domain([effectiveYMin, yMax])
                        .range([colorbarHeight, 0]);

                    // Colorbar gradient
                    const gradientId = `gradient-${i}-${Date.now()}`;
                    const gradient = svg.append('defs')
                        .append('linearGradient')
                        .attr('id', gradientId)
                        .attr('x1', '0%').attr('y1', '100%')
                        .attr('x2', '0%').attr('y2', '0%');

                    const nStops = 10;
                    for (let s = 0; s <= nStops; s++) {
                        const t = s / nStops;
                        // Interpolate from yMin to yMax for the gradient
                        const value = effectiveYMin + t * (yMax - effectiveYMin);
                        gradient.append('stop')
                            .attr('offset', `${t * 100}%`)
                            .attr('stop-color', colorScale(value));
                    }

                    colorbarG.append('rect')
                        .attr('width', colorbarWidth)
                        .attr('height', colorbarHeight)
                        .attr('fill', `url(#${gradientId})`);

                    // Colorbar axis
                    const colorbarAxis = d3.axisRight(colorbarScale)
                        .ticks(3)
                        .tickSize(3);

                    colorbarG.append('g')
                        .attr('transform', `translate(${colorbarWidth}, 0)`)
                        .call(colorbarAxis)
                        .selectAll('text')
                        .attr('font-size', '0.6rem')
                        .attr('fill', '#555');
                    colorbarG.selectAll('path,line').attr('stroke', '#777');
                }

                // Add flip button next to colorbar (for continuous/gradient tracks only)
                if (legendType === 'continuous' || legendType === 'constraint_stacked' || legendType === 'dbnsfp_stacked') {
                    const isFlipped = flippedTracks.has(trackId);
                    const flipBtn = colorbarG.append('g')
                        .attr('class', 'flip-btn')
                        .attr('transform', `translate(${colorbarWidth + 35}, ${colorbarHeight / 2})`)
                        .style('cursor', 'pointer');

                    flipBtn.append('circle')
                        .attr('r', 8)
                        .attr('fill', isFlipped ? '#e94560' : '#444')
                        .attr('stroke', '#666')
                        .attr('stroke-width', 1);

                    flipBtn.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('font-size', '0.6rem')
                        .attr('fill', '#fff')
                        .attr('pointer-events', 'none')
                        .text('⇅');

                    flipBtn.append('title').text(isFlipped ? 'Color scale flipped - click to restore' : 'Click to flip color scale');

                    flipBtn.on('click', function(event) {
                        event.stopPropagation();
                        if (flippedTracks.has(trackId)) {
                            flippedTracks.delete(trackId);
                        } else {
                            flippedTracks.add(trackId);
                        }
                        renderChart();

                        // Update 3D structure coloring if this track is currently displayed
                        if (currentColorScheme === `track:${trackId}` && plugin && currentStructureGene) {
                            applyColorScheme(currentColorScheme);
                        }
                    });
                }

                // Add 3D overlay button for eligible tracks
                if (isEligibleForSphereOverlay(trackId) && window.molstarLoaded) {
                    const isOverlayed = trackOverlayState.overlayedTracks.some(t => t.trackId === trackId);
                    const overlay = trackOverlayState.overlayedTracks.find(t => t.trackId === trackId);

                    // Position after flip button if present, otherwise after colorbar
                    const xOffset = (legendType === 'continuous' || legendType === 'constraint_stacked' || legendType === 'dbnsfp_stacked')
                        ? colorbarWidth + 55  // After flip button
                        : colorbarWidth + 35; // After colorbar

                    const overlayBtn = colorbarG.append('g')
                        .attr('class', 'overlay-btn')
                        .attr('transform', `translate(${xOffset}, ${colorbarHeight / 2})`)
                        .style('cursor', 'pointer');

                    overlayBtn.append('circle')
                        .attr('r', 8)
                        .attr('fill', isOverlayed && overlay ? TRACK_OVERLAY_COLOR_NAMES[overlay.colorSlot] : '#444')
                        .attr('stroke', '#666')
                        .attr('stroke-width', 1);

                    overlayBtn.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('font-size', '0.55rem')
                        .attr('fill', '#fff')
                        .attr('pointer-events', 'none')
                        .text('3D');

                    overlayBtn.append('title').text(isOverlayed ? 'Remove 3D overlay' : 'Show on 3D structure');

                    // Store trackId on the button for later updates
                    overlayBtn.node().dataset = { trackId: trackId };
                    overlayBtn.classed('track-overlay-btn', true);

                    overlayBtn.on('click', async function(event) {
                        event.stopPropagation();
                        const isCurrentlyOverlayed = trackOverlayState.overlayedTracks.some(t => t.trackId === trackId);
                        if (isCurrentlyOverlayed) {
                            await removeTrackOverlay(trackId);
                        } else {
                            if (trackOverlayState.overlayedTracks.length >= 2) {
                                alert('Maximum 2 track overlays allowed. Remove one first.');
                                return;
                            }
                            await addTrackOverlay(trackId);
                        }
                        renderChart();  // Re-render to update button state
                    });
                }
              } catch (error) {
                console.error(`Error rendering track ${trackId}:`, error);
              }
            });

            // Canvas tooltip hit detection - attach to canvasContainer (parent) for better event capture
            // We'll use the SVG overlay's mousemove for tooltip detection since it's on top
            function handleTooltipFromMouse(event) {
                // Get mouse position relative to canvas tracks area
                const canvasRect = canvasTracksContainer.getBoundingClientRect();
                const mouseX = event.clientX - canvasRect.left;
                const mouseY = event.clientY - canvasRect.top;
                
                // Check if mouse is within canvas tracks area
                if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {
                    hideTooltip();
                    return;
                }
                
                // Which track?
                const trackIndex = Math.floor(mouseY / TRACK_HEIGHT);
                if (trackIndex < 0 || trackIndex >= tracks.length) {
                    hideTooltip();
                    return;
                }
                
                // Which position?
                const xScaleCurrent = currentZoomTransform.rescaleX(xScale);
                const filteredIdx = Math.round(xScaleCurrent.invert(mouseX));
                
                // Find the data point
                const dataPoint = positionsData.find(p => p.filtered_idx === filteredIdx);
                if (!dataPoint) {
                    hideTooltip();
                    return;
                }
                
                // Get the value for this track
                const trackInfo = trackCanvases[trackIndex];
                const posIdx = positionsData.indexOf(dataPoint);
                const value = trackInfo.values[posIdx];
                
                // Show tooltip
                showTooltip(event, dataPoint, trackInfo.trackId, value, trackInfo.isDomain);
            }
            
            // Attach tooltip handler to interaction rect (handles pan mode)
            interactionRect.on('mousemove.tooltip', function(event) {
                handleTooltipFromMouse(event);
            });
            interactionRect.on('mouseleave.tooltip', function() {
                hideTooltip();
            });
            
            // Also attach to canvas container for when brush is active (pan off)
            canvasTracksContainer.addEventListener('mousemove', handleTooltipFromMouse);
            canvasTracksContainer.addEventListener('mouseleave', () => {
                hideTooltip();
            });
            
            // Crosshair: dotted red line across all tracks (toggled)
            // Apply clipPath to ensure highlight rect doesn't overflow plot area
            const crosshairLayer = g.append('g')
                .attr('class', 'crosshair-layer')
                .attr('clip-path', `url(#${clipId})`)
                .style('pointer-events', 'none');
            
            const crosshairLine = crosshairLayer.append('line')
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', 'red')
                .attr('stroke-width', 1.5)
                .attr('stroke-dasharray', '4 4')
                .attr('opacity', 0);

            // Residue highlight rectangle (for 3D structure hover)
            const residueHighlightRect = crosshairLayer.append('rect')
                .attr('class', 'residue-highlight-rect')
                .attr('y', 0)
                .attr('height', height)
                .attr('opacity', 0);

            // Attach mousemove to SVG for crosshair (doesn't block interactions)
            svg.on('mousemove', function(event) {
                if (!crosshairEnabled) {
                    crosshairLine.attr('opacity', 0);
                    return;
                }
                
                const [mx, my] = d3.pointer(event, g.node());
                const xScaleCurrent = currentZoomTransform.rescaleX(xScale);
                
                // Check if mouse is within the chart area
                if (mx < 0 || mx > width || my < 0 || my > height) {
                    crosshairLine.attr('opacity', 0);
                    return;
                }
                
                crosshairLine
                    .attr('x1', mx)
                    .attr('x2', mx)
                    .attr('opacity', 1);
                
                const idx = Math.round(xScaleCurrent.invert(mx));
                const pos = positionsData.find(p => p.filtered_idx === idx);
                if (pos) {
                    document.getElementById('position-info').textContent = 
                        `${pos.chrom}:${pos.pos.toLocaleString()} | ${pos.gene_symbol || 'N/A'}`;
                }
            })
            .on('mouseleave', () => {
                crosshairLine.attr('opacity', 0);
            });
            
            // X Axis (at bottom)
            const xAxisG = g.append('g')
                .attr('class', 'x-axis axis')
                .attr('transform', `translate(0, ${height})`)
                .style('pointer-events', 'none'); // Don't block interactions
            
            function updateXAxis(scale) {
                const xAxis = d3.axisBottom(scale)
                    .ticks(10)
                    .tickFormat(d => {
                        const pos = positionsData.find(p => p.filtered_idx === Math.round(d));
                        if (pos) {
                            if (axisMode === 'aa' && pos.aa_pos !== undefined && pos.aa_pos !== null) {
                                return `${pos.aa_pos}`;
                            }
                            return `${pos.chrom}:${pos.pos.toLocaleString()}`;
                        }
                        return d;
                    });
                
                xAxisG.call(xAxis);
                xAxisG.selectAll('text')
                    .attr('transform', 'rotate(-45)')
                    .attr('text-anchor', 'end')
                    .attr('dx', '-0.5em')
                    .attr('dy', '0.5em')
                    .attr('fill', '#333'); // force readable labels
                xAxisG.selectAll('path,line')
                    .attr('stroke', '#555');
            }
            
            updateXAxis(xScaleZoomed);
            
            // X axis label
            const axisLabel = g.append('text')
                .attr('x', width / 2)
                .attr('y', height + 95)
                .attr('text-anchor', 'middle')
                .attr('fill', '#888')
                .attr('font-size', '0.8rem');
            const updateAxisLabel = () => {
                const modeText = axisMode === 'aa' ? 'AA Position' : 'Genomic Position (GRCh38)';
                const interactionText = panEnabled 
                    ? 'Drag to pan, scroll to zoom' 
                    : 'Click & drag to select region';
                axisLabel.text(`${modeText} – ${interactionText}`);
            };
            updateAxisLabel();
            
            // Zoom behavior with optimized canvas redrawing
            let zoomRAF = null;
            const zoom = d3.zoom()
                .scaleExtent([1, 100])  // Allow 1x to 100x zoom
                .translateExtent([[0, 0], [width, height]])
                .extent([[0, 0], [width, height]])
                .on('start', function(event) {
                    svg.style('cursor', 'grabbing');
                })
                .on('zoom', function(event) {
                    currentZoomTransform = event.transform;
                    
                    // Cancel pending frame
                    if (zoomRAF) cancelAnimationFrame(zoomRAF);
                    
                    // Schedule redraw with requestAnimationFrame for smooth performance
                    zoomRAF = requestAnimationFrame(() => {
                        const newXScale = event.transform.rescaleX(xScale);
                        const newBarWidth = Math.max(1, (width / positionsData.length) * event.transform.k);
                        
                        // Redraw all track canvases
                        trackCanvases.forEach(({ canvas, trackId, values, colorScale, isClinVarStacked, isClinVarVariants, isVariantFrequency, isCoverage, isDomain, isConstraintStacked, isDbNSFPStacked, usesHeightBars, yMax, yMin }) => {
                            // Use specialized drawing method based on track type
                            if (isConstraintStacked) {
                                canvas.drawConstraintStacked(values, newXScale, colorScale, newBarWidth);
                            } else if (isDbNSFPStacked) {
                                const scoreRange = trackId === 'AlphaMissense_stacked' ? [0, 1] : [-10, 5];
                                canvas.drawDbNSFPStacked(values, newXScale, colorScale, newBarWidth, scoreRange);
                            } else if (isClinVarStacked) {
                                canvas.drawClinVarStacked(positionsData, newXScale, newBarWidth);
                            } else if (isClinVarVariants) {
                                canvas.drawClinVarVariants(values, newXScale, newBarWidth);
                            } else if (isVariantFrequency) {
                                canvas.drawVariantFrequency(values, newXScale, newBarWidth, trackId);
                            } else if (isCoverage) {
                                canvas.drawCoverageArea(positionsData, values, newXScale, newBarWidth, trackId);
                            } else if (isDomain && trackId === 'domains') {
                                canvas.drawDomains(positionsData, newXScale, newBarWidth);
                            } else if (usesHeightBars) {
                                canvas.drawHeightBars(positionsData, values, newXScale, colorScale, newBarWidth, yMax, yMin);
                            } else {
                                canvas.drawBars(positionsData, values, newXScale, colorScale, newBarWidth);
                            }
                        });
                        
                        // Update x-axis
                        updateXAxis(newXScale);
                    });
                })
                .on('end', function(event) {
                    svg.style('cursor', 'grab');
                });
            
            // Create brush for box select (only active when pan is disabled)
            const brush = d3.brushX()
                .extent([[0, 0], [width, height]])
                .on('end', function(event) {
                    if (!event.selection || panEnabled) return;
                    
                    const [x0, x1] = event.selection;
                    const xScaleCurrent = currentZoomTransform.rescaleX(xScale);
                    
                    // Get filtered indices at selection bounds
                    const idx0 = Math.floor(xScaleCurrent.invert(x0));
                    const idx1 = Math.ceil(xScaleCurrent.invert(x1));
                    
                    // Store current range before changing it (for reset functionality)
                    if (rangeBeforeBoxSelect === null) {
                        rangeBeforeBoxSelect = [...currentRange];
                    }
                    
                    // Update range and reload data
                    currentRange = [
                        Math.max(0, idx0),
                        Math.min(positionsData[positionsData.length - 1].filtered_idx, idx1)
                    ];
                    
                    document.getElementById('start-input').value = currentRange[0];
                    document.getElementById('end-input').value = currentRange[1];
                    
                    // Clear brush
                    brushGroup.call(brush.move, null);
                    
                    // Reload data for new range
                    loadData();
                });
            
            const brushGroup = g.append('g')
                .attr('class', 'brush')
                .call(brush)
                .style('display', panEnabled ? 'none' : 'block')
                .style('pointer-events', 'all'); // Enable interaction
            
            // Add tooltip handling to brush overlay (for when pan is off)
            brushGroup.on('mousemove.tooltip', function(event) {
                handleTooltipFromMouse(event);
            });
            brushGroup.on('mouseleave.tooltip', function() {
                hideTooltip();
            });
            
            // Function to toggle between pan and box select modes
            function updateInteractionMode() {
                if (panEnabled) {
                    brushGroup.style('display', 'none');
                    interactionRect.style('pointer-events', 'all');
                    interactionRect.style('cursor', 'grab');
                    interactionRect.call(zoom);
                } else {
                    brushGroup.style('display', 'block');
                    interactionRect.style('pointer-events', 'none');
                    interactionRect.on('.zoom', null);
                }
                updateAxisLabel();
            }
            
            // Apply zoom to interaction rect (initial state)
            interactionRect.call(zoom);
            
            // Apply existing transform if any
            if (currentZoomTransform !== d3.zoomIdentity) {
                svg.call(zoom.transform, currentZoomTransform);
            }
            
            // Add zoom controls + pan toggle + crosshair toggle
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'zoom-controls';
            controlsDiv.innerHTML = `
                <button id="zoom-in" title="Zoom In">+</button>
                <button id="zoom-out" title="Zoom Out">−</button>
                <button id="zoom-reset" title="Reset Zoom">⟲</button>
                <button id="pan-toggle" title="Toggle pan mode (drag to pan)" aria-pressed="${panEnabled}">⇔</button>
                <button id="axis-toggle" title="Toggle axis mode" aria-pressed="${axisMode === 'aa'}">AA</button>
            `;
            container.appendChild(controlsDiv);
            
            // Zoom control handlers - use svg element for programmatic zoom
            document.getElementById('zoom-in').onclick = () => {
                svg.transition().duration(300).call(zoom.scaleBy, 1.5);
            };
            document.getElementById('zoom-out').onclick = () => {
                svg.transition().duration(300).call(zoom.scaleBy, 0.67);
            };
            document.getElementById('zoom-reset').onclick = () => {
                currentZoomTransform = d3.zoomIdentity;

                // If box-select changed the range, restore the original range
                if (rangeBeforeBoxSelect !== null) {
                    currentRange = [...rangeBeforeBoxSelect];
                    document.getElementById('start-input').value = currentRange[0];
                    document.getElementById('end-input').value = currentRange[1];
                    rangeBeforeBoxSelect = null; // Clear stored range

                    // Reload data to original range
                    loadData();
                } else {
                    // Just reset the visual zoom - use svg element for programmatic zoom
                    svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
                }
            };

            // Pan toggle button handler
            const panBtn = document.getElementById('pan-toggle');
            const updatePanToggle = () => {
                panBtn.setAttribute('aria-pressed', String(panEnabled));
                panBtn.classList.toggle('crosshair-active', panEnabled);
                panBtn.title = panEnabled ? 'Pan: ON (drag to pan)' : 'Pan: OFF (box select enabled)';
            };
            panBtn.onclick = () => {
                panEnabled = !panEnabled;
                updatePanToggle();
                updateInteractionMode();
            };
            updatePanToggle();
            
            const axisBtn = document.getElementById('axis-toggle');
            const updateAxisToggle = () => {
                axisBtn.setAttribute('aria-pressed', String(axisMode === 'aa'));
                axisBtn.classList.toggle('crosshair-active', axisMode === 'aa');
                axisBtn.title = axisMode === 'aa' ? 'Axis mode: AA' : 'Axis mode: Genomic';
                // Note: renderChart() will call updateAxisLabel()
            };
            axisBtn.onclick = () => {
                axisMode = axisMode === 'aa' ? 'genomic' : 'aa';
                updateAxisToggle();
                renderChart();
            };
            updateAxisToggle();
        }
        
        // Tooltip functions
        function showTooltip(event, d, trackId, value, isDomain = false) {
            const tooltip = document.getElementById('tooltip');
            const isClinVarStacked = isClinVarStackedTrack(trackId);
            const isClinVar = isClinVarTrack(trackId);
            const isConstraintStacked = isConstraintStackedTrack(trackId);
            const isDbNSFPStacked = isDbNSFPStackedTrack(trackId);

            let tooltipContent = `
                <div class="tooltip-title">${simplifyTrackName(trackId)}</div>
                <div class="tooltip-row">Position: <span class="tooltip-value">${d.chrom}:${d.pos.toLocaleString()}</span></div>
                ${d.aa_pos !== undefined && d.aa_pos !== null ? `<div class="tooltip-row">AA pos: <span class="tooltip-value">${d.aa_pos}</span></div>` : ''}
                <div class="tooltip-row">Gene: <span class="tooltip-value">${d.gene_symbol || 'N/A'}</span></div>
            `;

            if (isConstraintStacked) {
                // Show constraint variant predictions
                const variants = value && value.variants ? value.variants : [];

                tooltipContent += `<div class="tooltip-row">Variants: <span class="tooltip-value">${variants.length}</span></div>`;

                if (variants.length > 0) {
                    tooltipContent += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;"><strong>Pathogenicity Predictions:</strong></div>`;

                    // Define color function matching the color scale
                    const getPathogenicityColor = (pred) => {
                        if (pred <= 0.3) {
                            // Green to Yellow
                            const t = pred / 0.3;
                            return `rgb(${Math.round(46 + (241-46)*t)}, ${Math.round(204 + (196-204)*t)}, ${Math.round(113 + (15-113)*t)})`;
                        } else if (pred <= 0.7) {
                            // Yellow to Orange
                            const t = (pred - 0.3) / 0.4;
                            return `rgb(${Math.round(241 + (230-241)*t)}, ${Math.round(196 + (126-196)*t)}, ${Math.round(15 + (34-15)*t)})`;
                        } else {
                            // Orange to Red
                            const t = (pred - 0.7) / 0.3;
                            return `rgb(${Math.round(230 + (231-230)*t)}, ${Math.round(126 + (76-126)*t)}, ${Math.round(34 + (60-34)*t)})`;
                        }
                    };

                    variants.forEach(variant => {
                        const color = getPathogenicityColor(variant.pred);
                        // Get consequence info for display
                        const csqInfo = variant.consequence ? CONSEQUENCE_CATEGORIES[variant.consequence] : null;
                        const csqLabel = csqInfo ? csqInfo.abbrev : '';
                        const csqColor = csqInfo ? csqInfo.color : '#888';
                        tooltipContent += `
                            <div class="tooltip-row" style="font-size: 11px; margin-left: 8px;">
                                <span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 5px; vertical-align: middle; border: 1px solid #000;"></span>
                                <span class="tooltip-value">${variant.allele}: ${variant.pred.toFixed(3)}</span>
                                ${csqLabel ? `<span style="color: ${csqColor}; margin-left: 8px; font-size: 10px;">(${csqLabel})</span>` : ''}
                            </div>
                        `;
                    });
                } else {
                    tooltipContent += `<div class="tooltip-row" style="color: #888;">No variant predictions</div>`;
                }
            } else if (isDbNSFPStacked) {
                // Show dbNSFP variant scores
                const variants = value && value.variants ? value.variants : [];
                const scoreName = trackId === 'AlphaMissense_stacked' ? 'AlphaMissense' : 'ESM1b';
                const scoreRange = trackId === 'AlphaMissense_stacked' ? [0, 1] : [-10, 5];

                tooltipContent += `<div class="tooltip-row">Variants: <span class="tooltip-value">${variants.length}</span></div>`;

                if (variants.length > 0) {
                    tooltipContent += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;"><strong>${scoreName} Scores:</strong></div>`;

                    // Define color function matching the color scale
                    const getScoreColor = (score) => {
                        // Normalize score to 0-1 range
                        const [minS, maxS] = scoreRange;
                        const normalized = Math.max(0, Math.min(1, (score - minS) / (maxS - minS)));
                        if (normalized <= 0.3) {
                            const t = normalized / 0.3;
                            return `rgb(${Math.round(72 + (220-72)*t)}, ${Math.round(139 + (220-139)*t)}, ${Math.round(73 + (4-73)*t)})`;
                        } else if (normalized <= 0.7) {
                            const t = (normalized - 0.3) / 0.4;
                            return `rgb(${Math.round(220 + (230-220)*t)}, ${Math.round(220 + (126-220)*t)}, ${Math.round(4 + (34-4)*t)})`;
                        } else {
                            const t = (normalized - 0.7) / 0.3;
                            return `rgb(${Math.round(230 + (204-230)*t)}, ${Math.round(126 + (0-126)*t)}, ${Math.round(34 + (0-34)*t)})`;
                        }
                    };

                    variants.forEach(variant => {
                        const color = getScoreColor(variant.score);
                        const percentileText = variant.percentile !== null ? ` (${variant.percentile.toFixed(1)}th %ile)` : '';
                        tooltipContent += `
                            <div class="tooltip-row" style="font-size: 11px; margin-left: 8px;">
                                <span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 5px; vertical-align: middle; border: 1px solid #000;"></span>
                                <span class="tooltip-value">${variant.allele}: ${variant.score.toFixed(3)}${percentileText}</span>
                            </div>
                        `;
                    });
                } else {
                    tooltipContent += `<div class="tooltip-row" style="color: #888;">No variant scores</div>`;
                }
            } else if (isClinVarStacked) {
                // Show ClinVar labels
                const labels = d['clinvar.clinvar_label_list'];
                const count = d['clinvar.clinvar_count'] || 0;
                
                // Filter labels based on current filter
                const filteredLabels = labels ? labels.filter(l => clinvarLabelPassesFilter(l)) : [];
                const filteredCount = filteredLabels.length;
                
                tooltipContent += `<div class="tooltip-row">ClinVar Variants: <span class="tooltip-value">${count}</span>`;
                if (filteredCount !== count && count > 0) {
                    tooltipContent += ` <span style="color: #888;">(${filteredCount} shown)</span>`;
                }
                tooltipContent += `</div>`;
                
                if (labels && Array.isArray(labels) && labels.length > 0) {
                    tooltipContent += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;"><strong>Clinical Significance:</strong></div>`;
                    
                    // Count each label type
                    const labelCounts = {};
                    labels.forEach(label => {
                        labelCounts[label] = (labelCounts[label] || 0) + 1;
                    });
                    
                    Object.entries(labelCounts).forEach(([label, cnt]) => {
                        const color = getClinVarColor(label);
                        const isFiltered = !clinvarLabelPassesFilter(label);
                        tooltipContent += `
                            <div class="tooltip-row" style="font-size: 11px; margin-left: 8px; ${isFiltered ? 'opacity: 0.4; text-decoration: line-through;' : ''}">
                                <span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 5px; vertical-align: middle;"></span>
                                <span class="tooltip-value">${label.replace(/_/g, ' ')}</span>
                                ${cnt > 1 ? `<span style="color: #888;"> (×${cnt})</span>` : ''}
                                ${isFiltered ? '<span style="color: #888; font-size: 10px;"> (filtered)</span>' : ''}
                            </div>
                        `;
                    });
                } else {
                    tooltipContent += `<div class="tooltip-row" style="color: #888;">No ClinVar annotations</div>`;
                }
            } else if (isDomain) {
                // Show domain-specific details (new array format)
                const domains = d['domains'];
                const hasDomain = domains && Array.isArray(domains) && domains.length > 0;
                
                tooltipContent += `<div class="tooltip-row">Domain: <span class="tooltip-value" style="color: ${hasDomain ? '#00b894' : '#888'}">${hasDomain ? 'Present' : 'Absent'}</span></div>`;
                
                if (hasDomain) {
                    tooltipContent += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;"><strong>Domain Details:</strong></div>`;
                    
                    domains.forEach((domain) => {
                        const name = domain.domain_name || 'Unknown';
                        const type = domain.domain_type || '';
                        const id = domain.domain_id || '';
                        const source = domain.source_db || '';
                        const startAA = domain.start_aa;
                        const endAA = domain.end_aa;
                        
                        tooltipContent += `
                            <div class="tooltip-row" style="font-size: 11px; margin-left: 8px;">
                                <span class="tooltip-value" style="color: #00b894">${name}</span>
                                ${type ? `<span style="color: #888;"> (${type})</span>` : ''}
                            </div>
                        `;
                        if (id || (startAA !== undefined && endAA !== undefined)) {
                            tooltipContent += `<div class="tooltip-row" style="font-size: 10px; margin-left: 16px; color: #666;">`;
                            if (id) tooltipContent += `ID: ${id}`;
                            if (source) tooltipContent += ` | ${source}`;
                            if (startAA !== undefined && endAA !== undefined) {
                                tooltipContent += ` | AA ${startAA}-${endAA}`;
                            }
                            tooltipContent += `</div>`;
                        }
                    });
                }
            } else if (isClinVar && trackId === 'clinvar.clinvar_count') {
                // ClinVar count track
                tooltipContent += `<div class="tooltip-row">ClinVar Variants: <span class="tooltip-value">${value !== null ? Math.round(value) : 'N/A'}</span></div>`;
            } else {
                // Regular numeric track
                // Check if this is a raw O/E track (transformed to constraint score)
                const isRawOE = isOETrack(trackId) && !isPercentileTrack(trackId);
                if (isRawOE) {
                    // Show constraint score interpretation for raw O/E tracks
                    const label = value > 0.5 ? 'Constrained' : (value < -0.5 ? 'Positive Selection' : 'Neutral');
                    tooltipContent += `<div class="tooltip-row">Constraint: <span class="tooltip-value">${value !== null ? value.toFixed(3) : 'N/A'}</span></div>`;
                    tooltipContent += `<div class="tooltip-row" style="font-size: 10px; color: #888;">(1 = constrained, 0 = neutral, -1 = positive selection)</div>`;
                } else {
                    tooltipContent += `<div class="tooltip-row">Value: <span class="tooltip-value">${value !== null ? value.toFixed(3) : 'N/A'}</span></div>`;
                }
            }
            
            // Add training label counts if this is a training track
            if (trackId.startsWith('training.')) {
                const unlabelled = d['training.train_counts.unlabelled'] || 0;
                const labelled = d['training.train_counts.labelled'] || 0;
                const unlabelledHQ = d['training.train_counts.unlabelled_high_qual'] || 0;
                const labelledHQ = d['training.train_counts.labelled_high_qual'] || 0;
                
                if (unlabelled + labelled + unlabelledHQ + labelledHQ > 0) {
                    tooltipContent += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px;"><strong>Training Labels:</strong></div>`;
                    tooltipContent += `<div class="tooltip-row" style="font-size: 11px; margin-left: 8px;">Labelled: ${labelled} (HQ: ${labelledHQ})</div>`;
                    tooltipContent += `<div class="tooltip-row" style="font-size: 11px; margin-left: 8px;">Unlabelled: ${unlabelled} (HQ: ${unlabelledHQ})</div>`;
                }
            }
            
            tooltipContent += `<div class="tooltip-row" style="margin-top: 4px; font-size: 10px; color: #666;">Index: ${d.filtered_idx}</div>`;
            
            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            
            document.getElementById('position-info').textContent = 
                `${d.chrom}:${d.pos.toLocaleString()} | ${d.gene_symbol || 'N/A'}`;
            
            // Highlight corresponding residue in 3D structure (if structure panel is open)
            if (typeof onTrackPositionHover === 'function') {
                onTrackPositionHover(d);
            }
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Search functionality
        async function handleSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            
            document.getElementById('status-text').textContent = 'Searching...';
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/search/gene?gene=${encodeURIComponent(query)}&filter_id=${currentFilter}`
                );
                const results = await response.json();
                
                // API returns an array of matching genes
                if (results && results.length > 0) {
                    const gene = results[0];
                    // Center the view on the gene
                    const geneSize = gene.filtered_idx_end - gene.filtered_idx_start + 1;
                    const padding = 0; // show only the gene span
                    
                    currentRange = [
                        Math.max(0, gene.filtered_idx_start - padding),
                        gene.filtered_idx_end + padding
                    ];
                    document.getElementById('start-input').value = currentRange[0];
                    document.getElementById('end-input').value = currentRange[1];
                    rangeBeforeBoxSelect = null; // Clear stored range when navigating to gene
                    document.getElementById('status-text').textContent = `Found: ${gene.gene_symbol} (${gene.num_positions} positions)`;
                    loadData();

                    // Try to load structure for this gene (only if not already showing)
                    if (currentStructureGene !== gene.gene_symbol.toUpperCase()) {
                        loadGeneStructure(gene.gene_symbol);
                    }
                } else {
                    document.getElementById('status-text').textContent = 'Gene not found';
                }
            } catch (e) {
                console.error('Search failed:', e);
                document.getElementById('status-text').textContent = 'Search failed';
            }
        }
        
        // Navigate to gene + AA position range
        async function navigateToGeneAA() {
            const gene = document.getElementById('gene-aa-input').value.trim();
            const aaStart = parseInt(document.getElementById('aa-start-input').value);
            const aaEnd = parseInt(document.getElementById('aa-end-input').value);
            
            // Validation
            if (!gene || isNaN(aaStart) || isNaN(aaEnd) || aaStart > aaEnd) {
                document.getElementById('status-text').textContent = 'Invalid AA range';
                setTimeout(() => {
                    document.getElementById('status-text').textContent = 'Ready';
                }, 2000);
                return;
            }
            
            document.getElementById('status-text').textContent = `Searching for ${gene} AA ${aaStart}-${aaEnd}...`;
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/gene-aa-lookup?filter_id=${currentFilter}&gene=${encodeURIComponent(gene)}&aa_start=${aaStart}&aa_end=${aaEnd}`
                );
                
                if (!response.ok) {
                    const error = await response.json();
                    document.getElementById('status-text').textContent = error.detail || 'Gene/AA range not found';
                    setTimeout(() => {
                        document.getElementById('status-text').textContent = 'Ready';
                    }, 3000);
                    return;
                }
                
                const result = await response.json();
                
                // Update view with padding
                const padding = Math.floor((result.compressed_end - result.compressed_start) * 0.1) || 10;
                currentRange = [
                    Math.max(0, result.compressed_start - padding),
                    result.compressed_end + padding
                ];
                
                document.getElementById('start-input').value = currentRange[0];
                document.getElementById('end-input').value = currentRange[1];
                rangeBeforeBoxSelect = null; // Clear stored range when navigating to AA position
                
                await loadData();
                document.getElementById('status-text').textContent = 
                    `Showing ${result.gene} AA ${result.aa_start}-${result.aa_end} (${result.positions_found} positions)`;
                
            } catch (error) {
                console.error('Gene+AA lookup error:', error);
                document.getElementById('status-text').textContent = `Error: ${error.message}`;
                setTimeout(() => {
                    document.getElementById('status-text').textContent = 'Ready';
                }, 3000);
            }
        }
        
        // Update gene display banner
        async function updateGeneDisplay() {
            const [start, end] = currentRange;
            
            try {
                const response = await fetch(
                    `${API_BASE}/api/genes-in-window?filter_id=${currentFilter}&start=${start}&end=${end}`
                );
                const result = await response.json();
                
                const genesList = document.getElementById('genes-list');
                if (result.genes.length === 0) {
                    genesList.textContent = 'No genes in view';
                    genesList.style.color = '#888';
                } else {
                    genesList.textContent = result.genes.join(', ');
                    genesList.style.color = '#e94560';
                }
            } catch (error) {
                console.error('Failed to update gene display:', error);
                // Non-critical, don't show error to user
            }
        }
        
        // Event listeners
        document.getElementById('search-btn').addEventListener('click', handleSearch);
        document.getElementById('search-input').addEventListener('keypress', e => {
            if (e.key === 'Enter') {
                hideAutocomplete();
                handleSearch();
            }
        });

        // Autocomplete functionality
        const searchInput = document.getElementById('search-input');
        const autocompleteDropdown = document.getElementById('autocomplete-dropdown');
        let autocompleteTimeout = null;
        let selectedAutocompleteIndex = -1;

        function showAutocomplete(genes) {
            if (genes.length === 0) {
                hideAutocomplete();
                return;
            }

            autocompleteDropdown.innerHTML = genes.map((gene, idx) =>
                `<div class="autocomplete-item${idx === selectedAutocompleteIndex ? ' selected' : ''}" data-gene="${gene}">${gene}</div>`
            ).join('');

            autocompleteDropdown.classList.add('show');

            // Add click handlers
            autocompleteDropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', () => {
                    searchInput.value = item.dataset.gene;
                    hideAutocomplete();
                    handleSearch();
                });
            });
        }

        function hideAutocomplete() {
            autocompleteDropdown.classList.remove('show');
            autocompleteDropdown.innerHTML = '';
            selectedAutocompleteIndex = -1;
        }

        async function fetchAutocomplete(query) {
            if (query.length < 1) {
                hideAutocomplete();
                return;
            }

            // Skip autocomplete for position queries (chr:pos format)
            if (query.includes(':')) {
                hideAutocomplete();
                return;
            }

            try {
                const response = await fetch(
                    `${API_BASE}/api/search/gene/autocomplete?query=${encodeURIComponent(query)}&filter_id=${currentFilter}&limit=10`
                );
                const genes = await response.json();
                showAutocomplete(genes);
            } catch (error) {
                console.error('Autocomplete error:', error);
                hideAutocomplete();
            }
        }

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();

            // Debounce the autocomplete requests
            if (autocompleteTimeout) {
                clearTimeout(autocompleteTimeout);
            }

            autocompleteTimeout = setTimeout(() => {
                fetchAutocomplete(query);
            }, 150);
        });

        searchInput.addEventListener('keydown', (e) => {
            const items = autocompleteDropdown.querySelectorAll('.autocomplete-item');
            if (items.length === 0) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
                updateAutocompleteSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, 0);
                updateAutocompleteSelection(items);
            } else if (e.key === 'Tab' && selectedAutocompleteIndex >= 0) {
                e.preventDefault();
                searchInput.value = items[selectedAutocompleteIndex].dataset.gene;
                hideAutocomplete();
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        });

        function updateAutocompleteSelection(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('selected', idx === selectedAutocompleteIndex);
            });
        }

        // Hide autocomplete when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchInput.contains(e.target) && !autocompleteDropdown.contains(e.target)) {
                hideAutocomplete();
            }
        });

        document.getElementById('update-range-btn').addEventListener('click', () => {
            const start = parseInt(document.getElementById('start-input').value) || 0;
            const end = parseInt(document.getElementById('end-input').value) || 1000;
            currentRange = [start, end];
            rangeBeforeBoxSelect = null; // Clear stored range when manually updating
            loadData();
        });
        
        // AA navigation event listeners
        document.getElementById('gene-aa-btn').addEventListener('click', navigateToGeneAA);
        document.getElementById('aa-end-input').addEventListener('keypress', e => {
            if (e.key === 'Enter') navigateToGeneAA();
        });
        
        // Panel toggle (old edge button - kept for backwards compatibility)
        document.getElementById('panel-toggle').addEventListener('click', () => {
            toggleLeftPanel();
        });

        // Top bar panel toggle buttons (Cursor-style)
        document.getElementById('left-panel-btn').addEventListener('click', () => {
            toggleLeftPanel();
        });

        document.getElementById('right-panel-btn').addEventListener('click', () => {
            const panel = document.getElementById('structure-panel');
            const isCollapsed = panel.classList.contains('collapsed');
            toggleStructurePanel(isCollapsed);
            // Update button active state
            document.getElementById('right-panel-btn').classList.toggle('active', isCollapsed);
        });

        function toggleLeftPanel() {
            const panel = document.getElementById('track-panel');
            const toggle = document.getElementById('panel-toggle');
            const leftPanelBtn = document.getElementById('left-panel-btn');

            panel.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');

            // Update arrow direction
            toggle.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';

            // Update top bar button active state
            leftPanelBtn.classList.toggle('active', !panel.classList.contains('collapsed'));

            // Update toggle position
            if (panel.classList.contains('collapsed')) {
                toggle.style.left = '0';
            } else {
                setTimeout(() => {
                    toggle.style.left = panel.offsetWidth + 'px';
                }, 300);
            }

            // Re-render chart after animation
            setTimeout(() => {
                if (positionsData.length > 0) renderChart();
            }, 350);
        }

        // Window resize
        window.addEventListener('resize', () => {
            if (positionsData.length > 0) renderChart();
        });
        
        // =============================================================================
        // PANEL RESIZING
        // =============================================================================

        function initPanelResizing() {
            const leftDivider = document.getElementById('left-divider');
            const rightDivider = document.getElementById('right-divider');
            const trackPanel = document.getElementById('track-panel');
            const structurePanel = document.getElementById('structure-panel');
            const visualPanel = document.getElementById('visualization-panel');
            const panelToggle = document.getElementById('panel-toggle');

            let isResizing = false;
            let currentDivider = null;
            let startX = 0;
            let startWidth = 0;

            // Update panel toggle button position based on track panel width
            function updatePanelTogglePosition() {
                if (!trackPanel.classList.contains('collapsed')) {
                    panelToggle.style.left = trackPanel.offsetWidth + 'px';
                }
            }

            // Left divider - resizes track panel
            leftDivider.addEventListener('mousedown', (e) => {
                isResizing = true;
                currentDivider = 'left';
                startX = e.clientX;
                startWidth = trackPanel.offsetWidth;
                leftDivider.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            // Right divider - resizes structure panel
            rightDivider.addEventListener('mousedown', (e) => {
                isResizing = true;
                currentDivider = 'right';
                startX = e.clientX;
                startWidth = structurePanel.offsetWidth;
                rightDivider.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                if (currentDivider === 'left') {
                    const delta = e.clientX - startX;
                    const newWidth = Math.max(200, Math.min(600, startWidth + delta));
                    trackPanel.style.width = newWidth + 'px';
                    updatePanelTogglePosition();
                } else if (currentDivider === 'right') {
                    const delta = startX - e.clientX; // Reversed for right panel
                    const newWidth = Math.max(300, Math.min(800, startWidth + delta));
                    structurePanel.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    currentDivider = null;
                    leftDivider.classList.remove('resizing');
                    rightDivider.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Trigger resize event for D3 charts
                    window.dispatchEvent(new Event('resize'));
                }
            });

            // Initialize toggle position
            updatePanelTogglePosition();
        }

        // Initialize
        async function init() {
            await loadFilters();
            await loadTracks();
            await loadData();
            initStructurePanel();
            initPanelResizing();
        }

        init();
        
        // =============================================================================
        // STRUCTURE PANEL (Mol* 3D Viewer Integration)
        // =============================================================================
        
        // Structure panel state
        let plugin = null;  // Mol* PluginContext - the main plugin instance
        let currentStructureGene = null;
        let structureMetadata = null;
        let currentColorScheme = 'default';
        let currentAggregation = 'max';  // 'max', 'min', or 'mean'
        let highlightedResidues = new Set();
        let structureResidueData = null;  // Cached residue data for coloring
        let isLoadingStructure = false;  // Guard against concurrent loads
        let lastAppliedColorData = null;  // Cache for re-applying colors
        let lastAppliedTrackId = null;   // Track ID for cached colors
        // Track coloring via native Mol* color theme
        const trackColorMap = new Map(); // key: label_seq_id (int), value: 0xRRGGBB
        let trackThemeRegistered = false;
        let trackThemeVersion = 0; // Bumped each time trackColorMap changes; used as contextHash
        let defaultColorThemeName = null; // captured after initial structure load

        /**
         * Collect all StructureComponentRef objects from the hierarchy.
         * updateRepresentationsTheme expects components (which have .representations),
         * NOT structures.
         */
        function getAllStructureComponents(plugin) {
            const out = [];
            const h = plugin?.managers?.structure?.hierarchy;
            const structs = h?.current?.structures ?? [];
            for (const s of structs) {
                const comps = s?.components ?? [];
                for (const c of comps) {
                    if (c && Array.isArray(c.representations)) out.push(c);
                }
            }
            return out;
        }

        function d3ColorStringToHex(colorStr) {
            try {
                const c = d3.color(colorStr);
                if (!c) return 0x808080;
                const rgb = c.rgb();
                return ((rgb.r & 255) << 16) | ((rgb.g & 255) << 8) | (rgb.b & 255);
            } catch (e) {
                return 0x808080;
            }
        }

        function captureDefaultColorTheme(plugin) {
            if (defaultColorThemeName) return;
            try {
                // Use helper to get components (consistent with other theme functions)
                const comps = getAllStructureComponents(plugin);
                const firstRepr = comps[0]?.representations?.[0];
                const themeName = firstRepr?.cell?.transform?.params?.colorTheme?.name || firstRepr?.cell?.params?.colorTheme?.name;
                if (themeName) {
                    defaultColorThemeName = themeName;
                }
            } catch (e) { /* ignore */ }
            // Fallback if we can't detect
            if (!defaultColorThemeName) defaultColorThemeName = 'chain-id';
        }

        function registerTrackColorTheme(plugin) {
            if (trackThemeRegistered) return;
            const registry = plugin?.representation?.structure?.themes?.colorThemeRegistry;
            if (!registry || !registry.add) {
                console.warn('[COLORING] colorThemeRegistry not available; cannot register track theme');
                return;
            }

            // Color is imported from the ES module
            const DEFAULT_COLOR = Color(0x808080);

            const provider = {
                name: 'track-color-theme',
                label: 'Track Color Theme',
                category: 'Custom',
                factory: (ctx, props) => {
                    let callCount = 0;
                    let hitCount = 0;
                    let missCount = 0;
                    
                    return {
                        factory: provider.factory,
                        granularity: 'group',
                        contextHash: props.version,
                        color: (location) => {
                            try {
                                const unit = location?.unit;
                                const element = location?.element;
                                const model = unit?.model;
                                const ah = model?.atomicHierarchy;
                                
                                if (!ah || element === undefined || element === null) {
                                    return DEFAULT_COLOR;
                                }

                                const resIdx = ah.residueAtomSegments?.index?.[element];
                                if (resIdx === undefined) {
                                    return DEFAULT_COLOR;
                                }

                                const seqId = ah.residues?.label_seq_id?.value(resIdx);
                                const hex = trackColorMap.get(seqId);
                                
                                // Debug logging (first 10 calls only)
                                callCount++;
                                if (callCount <= 10) {
                                    console.log(`[THEME color()] call #${callCount}: seqId=${seqId}, hex=${hex !== undefined ? '0x' + hex.toString(16) : 'MISS'}, mapSize=${trackColorMap.size}`);
                                }
                                
                                if (hex !== undefined) {
                                    hitCount++;
                                    return Color(hex);
                                } else {
                                    missCount++;
                                    if (missCount <= 5) {
                                        console.log(`[THEME color()] MISS for seqId=${seqId}, trackColorMap has keys:`, Array.from(trackColorMap.keys()).slice(0, 10));
                                    }
                                    return DEFAULT_COLOR;
                                }
                            } catch (e) {
                                console.warn('[THEME color()] error:', e.message);
                                return DEFAULT_COLOR;
                            }
                        },
                        props,
                        description: 'Colors residues by active track values.'
                    };
                },
                getParams: () => ({ version: 0 }),
                defaultValues: { version: 0 },
                isApplicable: () => true
            };

            try {
                registry.add(provider);
                trackThemeRegistered = true;
                console.log('[COLORING] Successfully registered track-color-theme');
            } catch (e) {
                console.warn('[COLORING] Failed to register track theme:', e.message);
            }
        }

        async function applyTrackTheme(plugin) {
            if (!plugin) return;
            captureDefaultColorTheme(plugin);
            registerTrackColorTheme(plugin);

            const comps = getAllStructureComponents(plugin);
            if (!comps.length) {
                console.warn('[COLORING] No components found to apply theme');
                return;
            }

            // Bump version so Mol* recomputes colors via contextHash
            trackThemeVersion++;
            
            console.log(`[THEME] Applying track-color-theme v${trackThemeVersion} to ${comps.length} components, trackColorMap.size=${trackColorMap.size}`);
            
            try {
                // Use plugin.build() to update each representation's colorTheme
                // This approach works reliably with the Mol* UMD bundle
                const update = plugin.build();
                let reprCount = 0;
                
                for (const comp of comps) {
                    for (const repr of (comp.representations || [])) {
                        const cell = repr?.cell;
                        if (!cell?.transform?.ref) continue;

                        // Skip the yellow sphere halo - it should keep its uniform yellow color
                        const tags = cell.transform?.tags || [];
                        if (tags.includes('residue-highlight-sphere')) {
                            continue;
                        }

                        const currentParams = { ...cell.transform.params };
                        currentParams.colorTheme = {
                            name: 'track-color-theme',
                            params: { version: trackThemeVersion }
                        };

                        update.to(cell.transform.ref).update(currentParams);
                        reprCount++;
                    }
                }
                
                if (reprCount > 0) {
                    await update.commit();
                    console.log(`[THEME] Applied track-color-theme v${trackThemeVersion} to ${reprCount} representations`);
                }
                
                plugin.canvas3d?.requestRender?.();
                
                // Verify the theme was actually applied
                setTimeout(() => {
                    const h = plugin.managers?.structure?.hierarchy;
                    const firstStruct = h?.current?.structures?.[0];
                    const firstComp = firstStruct?.components?.[0];
                    const firstRepr = firstComp?.representations?.[0];
                    const appliedTheme = firstRepr?.cell?.transform?.params?.colorTheme;
                    console.log('[THEME] Verification - representation colorTheme:', appliedTheme);
                    if (appliedTheme?.name !== 'track-color-theme') {
                        console.error('[THEME] ERROR: Theme not applied! Current theme:', appliedTheme?.name);
                    }
                }, 100);
            } catch (e) {
                console.error('[THEME] Failed to apply theme:', e.message, e.stack);
            }
        }

        async function restoreDefaultTheme(plugin) {
            if (!plugin) return;
            captureDefaultColorTheme(plugin);

            const comps = getAllStructureComponents(plugin);
            if (!comps.length) return;

            try {
                // Use plugin.build() to update each representation's colorTheme
                const update = plugin.build();
                let reprCount = 0;
                
                for (const comp of comps) {
                    for (const repr of (comp.representations || [])) {
                        const cell = repr?.cell;
                        if (!cell?.transform?.ref) continue;

                        // Skip the yellow sphere halo - it should keep its uniform yellow color
                        const tags = cell.transform?.tags || [];
                        if (tags.includes('residue-highlight-sphere')) {
                            continue;
                        }

                        const currentParams = { ...cell.transform.params };
                        currentParams.colorTheme = {
                            name: defaultColorThemeName,
                            params: {}
                        };

                        update.to(cell.transform.ref).update(currentParams);
                        reprCount++;
                    }
                }

                if (reprCount > 0) {
                    await update.commit();
                }

                plugin.canvas3d?.requestRender?.();
                console.log('[THEME] Restored default theme:', defaultColorThemeName);
            } catch (e) {
                console.error('[THEME] Failed to restore default theme:', e.message);
            }
        }

        let selectedResidue = null;      // Persistently selected residue (survives hover-out)
        let lastClickedLoci = null;      // Store loci for re-applying halo after color changes

        // Re-apply colors when tab becomes visible again
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && lastAppliedColorData && plugin) {
                setTimeout(() => {
                    // Skip re-apply for default coloring (no custom data to restore)
                    if (currentColorScheme !== 'default') {
                        applyColorScheme(currentColorScheme);
                    }
                }, 200);
            }
        });
        
        // Domain colors
        const DOMAIN_COLORS = [
            '#e94560', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181',
            '#aa96da', '#fcbad3', '#a8d8ea', '#ffd3b6', '#dcedc1'
        ];
        
        function initStructurePanel() {
            // Structure panel toggle - single button that toggles both ways
            document.getElementById('structure-toggle-btn').addEventListener('click', () => {
                const panel = document.getElementById('structure-panel');
                const isCollapsed = panel.classList.contains('collapsed');
                toggleStructurePanel(isCollapsed);
            });

            // Color scheme dropdown
            document.getElementById('structure-color-select').addEventListener('change', (e) => {
                currentColorScheme = e.target.value;
                if (plugin && currentStructureGene) {
                    applyColorScheme(currentColorScheme);
                }
            });

            // Aggregation toggle buttons
            document.querySelectorAll('.agg-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.agg-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentAggregation = e.target.dataset.agg;
                    // Re-apply current color scheme with new aggregation (only for track-based coloring)
                    if (plugin && currentStructureGene && currentColorScheme !== 'default') {
                        applyColorScheme(currentColorScheme);
                    }
                });
            });


            // Aggregation dropdown (mirrors agg buttons if present)
            const aggSelect = document.getElementById('structure-aggregation-select');
            if (aggSelect) {
                aggSelect.value = currentAggregation;
                aggSelect.addEventListener('change', (e) => {
                    currentAggregation = e.target.value;
                    // Sync button UI if present
                    document.querySelectorAll('.agg-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.agg === currentAggregation);
                    });
                    // Re-apply current color scheme with new aggregation (only for track-based coloring)
                    if (plugin && currentStructureGene && currentColorScheme !== 'default') {
                        applyColorScheme(currentColorScheme);
                    }
                });
            }
            // Populate the color dropdown with selected tracks
            updateStructureColorDropdown();
        }  // End of initStructurePanel()

        
        function toggleStructurePanel(show) {
            const panel = document.getElementById('structure-panel');
            const toggleBtn = document.getElementById('structure-toggle-btn');
            const rightPanelBtn = document.getElementById('right-panel-btn');

            if (show) {
                panel.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                toggleBtn.textContent = '▶';  // Arrow pointing right (to collapse)
                toggleBtn.title = 'Hide 3D structure panel';
                rightPanelBtn?.classList.add('active');
            } else {
                panel.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                toggleBtn.textContent = '◀';  // Arrow pointing left (to expand)
                toggleBtn.title = 'Show 3D structure panel';
                rightPanelBtn?.classList.remove('active');
            }

            // Re-render chart after animation to fill available space
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 350);
        }

        // Re-apply colors when mouse enters structure panel (colors may have been cleared)
        let colorReapplyDebounce = null;
        document.getElementById('structure-panel')?.addEventListener('mouseenter', () => {
            if (colorReapplyDebounce) return;
            // Skip re-apply for default coloring (no custom data to restore)
            if (currentColorScheme !== 'default' && plugin && lastAppliedColorData) {
                colorReapplyDebounce = setTimeout(() => {
                    applyColorScheme(currentColorScheme);
                    colorReapplyDebounce = null;
                }, 300);
            }
        });
        
        async function checkAndLoadStructure() {
            // Check if current view includes SCN2A and auto-load it
            const genesInView = document.getElementById('genes-list').textContent;
            if (genesInView.includes('SCN2A')) {
                await loadGeneStructure('SCN2A');
            }
        }

        async function loadGeneStructure(gene) {
            if (!gene) return;

            // Prevent concurrent loads
            if (isLoadingStructure) return;

            // Skip if already showing this gene
            if (currentStructureGene === gene.toUpperCase() && plugin) return;

            isLoadingStructure = true;
            currentStructureGene = gene.toUpperCase();
            updateStatus(`Loading structure for ${currentStructureGene}...`);

            // Clear any existing track overlays when loading new structure
            if (plugin && trackOverlayState.overlayedTracks.length > 0) {
                try {
                    await clearAllTrackOverlays();
                } catch (e) {
                    console.warn('[OVERLAY] Error clearing overlays:', e);
                }
                trackOverlayState.overlayedTracks = [];
                trackOverlayState.sphereRefs.clear();
            }

            try {
                // Fetch structure metadata from API
                const response = await fetch(`${API_BASE}/api/structure/${gene}`);
                if (!response.ok) {
                    throw new Error(`Structure not available for ${gene}`);
                }
                
                structureMetadata = await response.json();

                // Initialize or update Mol* viewer
                await initMolstarViewer(gene);
                
                // Show the panel
                toggleStructurePanel(true);

                updateStatus(`Loaded structure for ${currentStructureGene}`);

            } catch (error) {
                console.error('Error loading structure:', error);
                updateStatus(`Error: ${error.message}`);
            } finally {
                isLoadingStructure = false;
            }
        }
        
        /**
         * Initialize Mol* Viewer - Using ES Module imports for full API access
         * =====================================================================
         * Uses imported Mol* plugin module for full access to StateTransforms,
         * StructureElement.Bundle, etc. for proper sphere overlays.
         */
        async function initMolstarViewer(gene) {
            const viewerContainer = document.getElementById('molstar-viewer');

            // Clear the container
            viewerContainer.innerHTML = '';

            // Get structure file URL
            const structureUrl = `${API_BASE}/api/structure/${gene}/file/alphafold`;

            try {
                // Initialize plugin using imported function
                plugin = await initMolstarPlugin(viewerContainer);

                // Expose for debugging
                window.molstarPlugin = plugin;
                window.__molstar = {
                    plugin: plugin,
                    StateTransforms: StateTransforms,
                    StructureElement: StructureElement,
                };

                // Log available APIs
                console.log('[Mol*] Plugin initialized via ES module.');
                console.log('[Mol*] StateTransforms:', StateTransforms);
                console.log('[Mol*] StructureElement:', StructureElement);
                console.log('[Mol*] StructureElement.Bundle:', StructureElement?.Bundle);

                // Load the structure using imported function
                await loadStructure(structureUrl, 'mmcif');

                // Capture default theme and register track theme for later
                captureDefaultColorTheme(plugin);
                registerTrackColorTheme(plugin);

                // Disable default selection/focus behaviors
                disableDefaultBehaviorsLocal(plugin);

                // Set up event handlers after structure is loaded
                setTimeout(() => {
                    setupMolstarEventHandlers();
                }, 300);

                // Set up zoom-only reset button after toolbar is rendered
                const trySetupZoomReset = (attempt = 1) => {
                    if (setupZoomOnlyReset(plugin)) {
                        console.log(`[ZOOM] Setup succeeded on attempt ${attempt}`);
                    } else if (attempt < 10) {
                        setTimeout(() => trySetupZoomReset(attempt + 1), 200 * attempt);
                    }
                };
                setTimeout(() => trySetupZoomReset(), 1200);

                // Apply initial color scheme after structure is fully rendered
                setTimeout(() => {
                    applyColorScheme(currentColorScheme);
                }, 1000);

            } catch (error) {
                console.error('[Mol*] Error initializing viewer:', error);
                updateStatus(`Error loading structure: ${error.message}`);
                throw error;
            }
        }

        /**
         * Disable default Mol* behaviors that interfere with our custom handling
         * This prevents:
         * - Automatic ball-and-stick representation on click
         * - Default hover highlighting
         * - Default Mol* tooltips
         * - Automatic focus/zoom on click
         */
        function disableDefaultBehaviorsLocal(plugin) {
            try {
                // 1. Disable default selection mode (prevents ball-and-stick on click)
                if (plugin.selectionMode !== undefined) {
                    plugin.selectionMode = 'none';
                }

                // 2. Disable marking/highlighting via Canvas3D settings
                // This is the KEY to preventing the green highlight on click/hover
                if (plugin.canvas3d?.setProps) {
                    plugin.canvas3d.setProps({
                        marking: {
                            enabled: false,  // Disable default marking
                        },
                        renderer: {
                            ...plugin.canvas3d.props?.renderer,
                            selectMark: false,  // Disable select marking
                            highlightStrength: 0,  // No highlight strength
                            selectStrength: 0,  // No select strength
                        },
                        // Make highlight color fully transparent
                        highlightColor: { r: 0, g: 0, b: 0, a: 0 },
                        selectColor: { r: 0, g: 0, b: 0, a: 0 },
                        // Disable far clipping plane so structure isn't cut off when zoomed/rotated
                        cameraClipping: {
                            far: false,
                            minNear: 20
                        },
                    });
                }
                
                // 3. Also set marking props directly if available
                if (plugin.canvas3d?.props?.marking !== undefined) {
                    try {
                        plugin.canvas3d.setProps({
                            marking: {
                                enabled: false,
                                highlightEdgeStrength: 0,
                                selectEdgeStrength: 0,
                                highlightEdgeColor: { r: 0, g: 0, b: 0, a: 0 },
                                selectEdgeColor: { r: 0, g: 0, b: 0, a: 0 },
                                innerEdgeFactor: 0,
                            }
                        });
            } catch (e) {
                        // Ignore if these specific props aren't available
                    }
                }

                // 4. Disable default highlight behavior
                if (plugin.managers?.interactivity?.lociHighlights) {
                    // Clear any existing highlights
                    plugin.managers.interactivity.lociHighlights.clearHighlights();
                }

                // 5. Disable default selection representation changes
                if (plugin.managers?.interactivity?.lociSelects) {
                    // We handle selection ourselves
                    plugin.managers.interactivity.lociSelects.deselectAll();
                }

                // 6. Disable default focus behavior on click
                // We'll implement our own gentle focus
                if (plugin.behaviors?.interaction?.focusLoci) {
                    // The focusLoci behavior auto-zooms on click - we override this
                    // by subscribing our own click handler that uses gentler zoom
                }

                // 7. Disable tooltip if using Mol* default tooltip
                // Note: We use our own custom tooltip, so disable any built-in ones
                if (plugin.canvas3d?.props?.tooltip) {
                    plugin.canvas3d.setProps({
                        tooltip: { enabled: false }
                    });
                }
                
                // 8. Disable the highlight info overlay (shows residue info on hover)
                // This is handled by CSS but also try programmatically
                if (plugin.customState) {
                    plugin.customState.showHighlightInfo = false;
                }

            } catch (e) { /* ignore */ }
        }
        
        /**
         * Find the Mol* reset button using exact selector for Mol* 4.5.0
         * Targets the "Reset Zoom" button inside the hover-box wrapper in viewport controls
         */
        function findMolstarResetButton() {
            // Narrow to the viewport controls buttons region first
            const controls = document.querySelector('#molstar-viewer .msp-viewport-controls-buttons');
            if (!controls) return null;

            // Target the exact icon button inside the hover-box wrapper
            // This is the button that shows the circular reset icon
            const btn = controls.querySelector(
                '.msp-hover-box-wrapper > button.msp-btn.msp-btn-icon.msp-btn-link-toggle-on[title="Reset Zoom"]'
            );
            
            // Fallback: try without the wrapper selector
            if (!btn) {
                const fallback = controls.querySelector('button.msp-btn.msp-btn-icon[title="Reset Zoom"]');
                if (fallback) return fallback;
                
                // Last fallback: any button with Reset in title
                return controls.querySelector('button[title*="Reset"]');
            }
            
            return btn;
        }
        
        /**
         * Setup the Mol* viewport reset button:
         * 1. Find it by title/tooltip (more robust than last-child)
         * 2. Clone to drop Mol*'s internal handlers
         * 3. Add .molstar-show-reset class so CSS shows only this button
         * 4. Override click to only reset zoom (camera radius), not orientation
         */
        function setupZoomOnlyReset(plugin) {
            if (!plugin?.canvas3d?.camera) return false;

            const resetBtn = findMolstarResetButton();
            if (!resetBtn) {
                console.warn('[ZOOM] reset button not found');
                return false;
            }

            // Clone to strip Mol* handlers
            const newResetBtn = resetBtn.cloneNode(true);
            newResetBtn.classList.add('molstar-show-reset');
            resetBtn.parentNode.replaceChild(newResetBtn, resetBtn);

            newResetBtn.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();

                // Mol*'s camera.state doesn't expose zoom changes from mouse wheel,
                // so we trigger Mol*'s built-in Reset Zoom action instead
                const internalReset = document.querySelector(
                    '#molstar-viewer .msp-hover-box-body button[title^="Set camera zoom"]'
                );

                if (internalReset) {
                    internalReset.click();  // invoke Mol*'s own zoom reset
                    console.log('[ZOOM] Triggered Mol* internal Reset Zoom');
                } else {
                    // Fallback: try to find by button text
                    const buttons = document.querySelectorAll('#molstar-viewer .msp-hover-box-body button');
                    for (const btn of buttons) {
                        if (btn.textContent?.includes('Reset Zoom') || btn.title?.includes('zoom')) {
                            btn.click();
                            console.log('[ZOOM] Triggered Mol* Reset Zoom via fallback');
                            return;
                        }
                    }
                    console.warn('[ZOOM] Internal Reset Zoom button not found');
                }
            });

            console.log('[ZOOM] setupZoomOnlyReset: configured reset button');
            return true;
        }
        
        function setupMolstarEventHandlers() {
            if (!plugin) return;

            try {
                // Check if the plugin state and behaviors are available
                if (!plugin.state || !plugin.state.data) return;

                // Set up hover tracking using canvas events (the most reliable method)
                setupCanvasHoverEvents();

                // Subscribe to camera reset events to clear halo/selection when user clicks Mol* reset button
                if (plugin.canvas3d?.camera?.stateChanged) {
                    let lastCameraSnapshot = null;
                    plugin.canvas3d.camera.stateChanged.subscribe((state) => {
                        if (state && state.mode === 'standard') {
                            const currentSnapshot = JSON.stringify(state.snapshot || {});
                            if (lastCameraSnapshot && currentSnapshot !== lastCameraSnapshot) {
                                // Camera changed significantly
                            }
                            lastCameraSnapshot = currentSnapshot;
                        }
                    });
                }

            } catch (e) { /* Event subscription is optional */ }
        }
        
        /**
         * Clear any custom coloring (overpaint) from the structure
         * This restores the default representation coloring (pLDDT for AlphaFold)
         */
        async function clearCustomColoring() {
            if (!plugin) return;
            
            try {
                // Find and remove any overpaint transforms
                const toRemove = [];
                plugin.state.data.cells.forEach((cell, ref) => {
                    // Check if this is a custom coloring transform
                    const tags = cell.transform?.tags || [];
                    if (tags.includes('custom-coloring')) {
                        toRemove.push(ref);
                    }
                    // Also check for overpaint transforms
                    if (cell.transform?.transformer?.id?.includes('overpaint')) {
                        toRemove.push(ref);
                    }
                });
                
                if (toRemove.length > 0) {
                    const update = plugin.build();
                    for (const ref of toRemove) {
                        update.delete(ref);
                    }
                    await update.commit();
                }
                
                // Clear cached color data
                lastAppliedColorData = null;
                lastAppliedTrackId = null;
                
            } catch (e) { /* ignore */ }
        }
        
        async function applyColorScheme(scheme) {
            if (!plugin || !currentStructureGene) return;

            // Hide colorbar by default (uses visibility to reserve space)
            document.getElementById('structure-colorbar').classList.remove('visible');

            // Capture camera state before any changes to preserve zoom level
            let savedCameraState = null;
            try {
                const camera = plugin.canvas3d?.camera;
                if (camera?.state) {
                    savedCameraState = { ...camera.state };
                }
            } catch (e) { /* ignore */ }

            try {
                if (scheme === 'default' || scheme === 'plddt') {
                    // Default coloring (AlphaFold pLDDT green) - restore the original theme
                    await clearCustomColoring();
                    trackColorMap.clear();
                    await restoreDefaultTheme(plugin);

                } else if (scheme === 'clinvar' || scheme === 'alphamissense') {
                    // Fetch residue data for coloring
                    const response = await fetch(
                        `${API_BASE}/api/protein/${currentStructureGene}/residues?start=1&end=${structureMetadata.protein_length}&filter_id=${currentFilter}`
                    );

                    if (response.ok) {
                        const data = await response.json();
                        const colorData = buildColorData(data.residues, scheme);

                        // Apply custom coloring
                        applyResidueColoring(colorData, scheme);
                    }

                } else if (scheme.startsWith('track:')) {
                    // Track-based coloring
                    const trackId = scheme.replace('track:', '');
                    await applyTrackColoring(trackId);
                }

                // Restore camera state after color change (halo should persist since it has its own tag)
                if (savedCameraState && plugin.canvas3d?.requestCameraReset) {
                    setTimeout(() => {
                        plugin.canvas3d.requestCameraReset({
                            snapshot: savedCameraState,
                            durationMs: 0  // Instant, no animation
                        });
                        console.log('[COLOR] Restored camera state after color change');
                    }, 150);
                }
            } catch (error) {
                console.error('Error applying color scheme:', error);
            }
        }

        // Apply uniform gray coloring to all structure representations
        async function applyUniformGrayColor(plugin) {
            if (!plugin) return;

            const comps = getAllStructureComponents(plugin);
            if (!comps.length) return;

            try {
                const update = plugin.build();
                let reprCount = 0;

                // Use a medium gray color (0x808080)
                const grayColor = 0x808080;

                for (const comp of comps) {
                    for (const repr of (comp.representations || [])) {
                        const cell = repr?.cell;
                        if (!cell?.transform?.ref) continue;

                        // Skip the yellow sphere halo - it should keep its uniform yellow color
                        const tags = cell.transform?.tags || [];
                        if (tags.includes('residue-highlight-sphere')) {
                            continue;
                        }

                        const currentParams = { ...cell.transform.params };
                        currentParams.colorTheme = {
                            name: 'uniform',
                            params: { value: grayColor }
                        };

                        update.to(cell.transform.ref).update(currentParams);
                        reprCount++;
                    }
                }

                if (reprCount > 0) {
                    await update.commit();
                }

                plugin.canvas3d?.requestRender?.();
                console.log('[THEME] Applied grayscale coloring');
            } catch (e) {
                console.error('[THEME] Failed to apply grayscale:', e.message);
            }
        }

        // Apply coloring based on a track field
        async function applyTrackColoring(trackId) {
    if (!plugin || !currentStructureGene) return;

    updateStatus(`Loading ${simplifyTrackName(trackId)} for structure...`);

    try {
        // Fetch residue-level rows (position-based). If the API already returns aggregated scores,
        // we will use them as-is; otherwise aggregate client-side by aa_pos.
        const url = `${API_BASE}/api/protein/${encodeURIComponent(currentStructureGene)}/residue-scores?field=${encodeURIComponent(trackId)}&filter_id=${encodeURIComponent(currentFilter)}&aggregation=${encodeURIComponent(currentAggregation)}`;
        const response = await fetch(url);

        if (!response.ok) {
            console.error('Failed to fetch residue scores:', response.statusText);
            updateStatus('Error loading residue scores');
            return;
        }

        const data = await response.json();
        structureResidueData = data;

        // If the API returns aggregated scores directly, keep existing behavior.
        if (data && data.scores && data.range) {
            const [minVal, maxVal] = data.range;
            const colorData = [];

            for (const [residue, score] of Object.entries(data.scores)) {
                const normalizedScore = (maxVal !== minVal)
                    ? (score - minVal) / (maxVal - minVal)
                    : 0.5;

                colorData.push({
                    residue: parseInt(residue, 10),
                    score: normalizedScore,
                    rawScore: score
                });
            }

            applyResidueColoring(colorData, trackId);
            updateStructureColorbar(trackId, minVal, maxVal);
            updateStatus(`Colored by ${simplifyTrackName(trackId)} (${currentAggregation})`);
            return;
        }

        // Otherwise, attempt to aggregate position-based rows client-side.
        const rows = Array.isArray(data) ? data : (data?.rows || data?.data || []);
        if (!Array.isArray(rows) || rows.length === 0) {
            updateStatus(`No data for ${simplifyTrackName(trackId)}`);
            return;
        }

        // Group values by aa_pos
        const byPos = new Map(); // aa_pos -> number[]
        for (const r of rows) {
            const pos = Number(r.aa_pos ?? r.position ?? r.pos ?? r.residue);
            const v = Number(r.value ?? r.score ?? r.count ?? r.freq ?? r.metric);
            if (!Number.isFinite(pos) || !Number.isFinite(v)) continue;
            if (!byPos.has(pos)) byPos.set(pos, []);
            byPos.get(pos).push(v);
        }

        if (byPos.size === 0) {
            updateStatus(`No numeric position values for ${simplifyTrackName(trackId)}`);
            return;
        }

        const agg = (arr) => {
            if (!arr.length) return null;
            if (currentAggregation === 'max') return Math.max(...arr);
            if (currentAggregation === 'min') return Math.min(...arr);
            // default mean
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        };

        const aggByPos = new Map(); // aa_pos -> aggregated number
        for (const [pos, arr] of byPos.entries()) {
            const a = agg(arr);
            if (a !== null && Number.isFinite(a)) aggByPos.set(pos, a);
        }

        const vals = Array.from(aggByPos.values());
        const minVal = Math.min(...vals);
        const maxVal = Math.max(...vals);
        const denom = (maxVal - minVal) || 1;

        const colorData = [];
        for (const [pos, a] of aggByPos.entries()) {
            const normalizedScore = (a - minVal) / denom;
            // For AlphaFold models, aa_pos usually matches label_seq_id; if you later
            // support PDB structures, insert a mapping step here (aa_pos -> label_seq_id).
            colorData.push({
                residue: parseInt(pos, 10),
                score: normalizedScore,
                rawScore: a
            });
        }

        applyResidueColoring(colorData, trackId);
        updateStructureColorbar(trackId, minVal, maxVal);
        updateStatus(`Colored by ${simplifyTrackName(trackId)} (${currentAggregation})`);

    } catch (error) {
        console.error('Error applying track coloring:', error);
        updateStatus('Error loading residue data');
    }
}

        // Update the structure colorbar
        function updateStructureColorbar(trackId, minVal, maxVal) {
            const colorbar = document.getElementById('structure-colorbar');
            const gradient = document.getElementById('structure-colorbar-gradient');

            if (minVal === null || maxVal === null) {
                colorbar.classList.remove('visible');
                return;
            }

            // Check if constraint or dbNSFP stacked track
            const isConstraintStacked = isConstraintStackedTrack(trackId);
            const isDbNSFPStacked = isDbNSFPStackedTrack(trackId);
            const isFlipped = flippedTracks.has(trackId);

            if (isConstraintStacked || isDbNSFPStacked) {
                // Use pathogenicity gradient for constraint stacked tracks
                const pathogenicityColors = [
                    '#00b894',  // benign (green)
                    '#00cec9',
                    '#74b9ff',
                    '#81ecec',
                    '#ffeaa7',
                    '#fdcb6e',
                    '#f39c12',
                    '#e17055',
                    '#d63031',
                    '#c0392b',  // pathogenic (dark red)
                ];

                const stops = pathogenicityColors.map((color, i) => {
                    const idx = isFlipped ? (9 - i) : i;
                    return `${pathogenicityColors[idx]} ${i * 10}%`;
                });

                gradient.style.background = `linear-gradient(to right, ${stops.join(', ')})`;

                // Labels for pathogenicity
                colorbar.querySelector('.structure-colorbar-min').textContent = isFlipped ? 'Pathogenic' : 'Benign';
                colorbar.querySelector('.structure-colorbar-max').textContent = isFlipped ? 'Benign' : 'Pathogenic';
            } else {
                // Get the color scale for this track
                const colorScale = getColorScaleForTrack(trackId, isFlipped);

                // Create gradient CSS
                const stops = [];
                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const value = minVal + t * (maxVal - minVal);
                    const color = colorScale(value);
                    stops.push(`${color} ${i * 10}%`);
                }

                gradient.style.background = `linear-gradient(to right, ${stops.join(', ')})`;

                // Update labels
                colorbar.querySelector('.structure-colorbar-min').textContent = minVal.toFixed(2);
                colorbar.querySelector('.structure-colorbar-max').textContent = maxVal.toFixed(2);
            }

            colorbar.classList.add('visible');
        }

        // Get color scale for a track (reuses the track viewer's color scales)
        function getColorScaleForTrack(trackId, isFlipped = false) {
            // Check track types
            const isOE = isOETrack(trackId);
            const isVIR = trackId.toLowerCase().includes('vir');
            const isConstraintStacked = isConstraintStackedTrack(trackId);
            const isDbNSFPStacked = isDbNSFPStackedTrack(trackId);
            const useConstraintGradient = usesConstraintColors(trackId);

            if (isConstraintStacked || isDbNSFPStacked || useConstraintGradient) {
                // Constraint predictions, counts, RGC, comparators use same custom gradient
                // High value = red (pathogenic/constrained), low value = green (benign/tolerant)
                const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                return d3.scaleLinear()
                    .domain(isFlipped ? [1, 0.7, 0.3, 0] : [0, 0.3, 0.7, 1])
                    .range(baseRange)
                    .clamp(true);
            } else if (isOE) {
                // O/E tracks: same gradient as constraint (green = low O/E = constrained, red = high O/E)
                const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                return d3.scaleLinear()
                    .domain(isFlipped ? [1, 0.7, 0.3, 0] : [0, 0.3, 0.7, 1])
                    .range(baseRange)
                    .clamp(true);
            } else if (isVIR) {
                // VIR tracks: same gradient as constraint
                const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                return d3.scaleLinear()
                    .domain(isFlipped ? [1, 0.7, 0.3, 0] : [0, 0.3, 0.7, 1])
                    .range(baseRange)
                    .clamp(true);
            } else {
                // Default: same gradient as constraint
                const baseRange = ['#488b49', '#dcdc04', '#e67e22', '#cc0000'];
                return d3.scaleLinear()
                    .domain(isFlipped ? [1, 0.7, 0.3, 0] : [0, 0.3, 0.7, 1])
                    .range(baseRange)
                    .clamp(true);
            }
        }
        
        function buildColorData(residues, scheme) {
            const colorData = [];
            
            for (const residue of residues) {
                let score = 0;
                let hasData = false;
                
                if (scheme === 'clinvar') {
                    // Check for pathogenic variants
                    for (const pos of residue.genomic_positions) {
                        if (pos.clinvar_count > 0) {
                            const labels = pos.clinvar_labels || [];
                            if (labels.some(l => l && (l.includes('Pathogenic') || l.includes('pathogenic')))) {
                                score = 1; // Pathogenic
                                hasData = true;
                            } else if (labels.some(l => l && l.includes('Uncertain'))) {
                                score = 0.5; // VUS
                                hasData = true;
                            }
                        }
                    }
                } else if (scheme === 'alphamissense') {
                    // Get max AlphaMissense score
                    for (const pos of residue.genomic_positions) {
                        if (pos.alphamissense !== null && pos.alphamissense !== undefined) {
                            score = Math.max(score, pos.alphamissense);
                            hasData = true;
                        }
                    }
                }
                
                if (hasData) {
                    colorData.push({
                        residue: residue.residue,
                        score: score,
                        scheme: scheme
                    });
                }
            }
            
            return colorData;
        }
        
        // Apply coloring to residues in the 3D structure
        function applyResidueColoring(colorData, trackId, retryCount = 0) {
            if (!plugin) {
                console.warn('applyResidueColoring: plugin not ready');
                return;
            }

            // Use native Mol* coloring
            applyResidueColoringMolstarNative(colorData, trackId, retryCount);
        }

        // Legacy PDBe visual coloring (kept for reference but not used)
        function applyResidueColoringPdbe(colorData, trackId, retryCount = 0) {
            const MAX_RETRIES = 10;

            // Cache the color data for re-application when tab becomes visible
            lastAppliedColorData = colorData;
            lastAppliedTrackId = trackId;

            // PDBe Molstar has limited custom coloring API
            // We use the color API to apply per-residue colors
            // Group residues into color buckets for efficiency

            const isFlipped = flippedTracks.has(trackId);
            const isComparator = COMPARATOR_TRACKS.has(trackId);
            const isOE = isOETrack(trackId);
            const isVIR = trackId.toLowerCase().includes('vir');
            const isConstraintStacked = isConstraintStackedTrack(trackId);

            // Create color buckets (10 buckets for gradient)
            const buckets = Array.from({ length: 10 }, () => []);

            colorData.forEach(d => {
                // Normalize score to 0-1 if not already
                let score = d.score;
                if (score < 0) score = 0;
                if (score > 1) score = 1;

                const bucketIdx = Math.min(9, Math.floor(score * 10));
                buckets[bucketIdx].push(d.residue);
            });

            // Apply coloring using selections with different colors
            // PDBe Molstar supports coloring via the `color` API
            try {
                // Build color selections
                const colorSelections = [];

                // Pathogenicity gradient for constraint stacked tracks: green -> yellow -> orange -> red
                const pathogenicityColors = [
                    '#00b894',  // 0.0 - benign (green)
                    '#00cec9',  // 0.1 - (teal-green)
                    '#74b9ff',  // 0.2 - (light blue)
                    '#81ecec',  // 0.3 - (cyan)
                    '#ffeaa7',  // 0.4 - (light yellow)
                    '#fdcb6e',  // 0.5 - (yellow)
                    '#f39c12',  // 0.6 - (orange)
                    '#e17055',  // 0.7 - (dark orange)
                    '#d63031',  // 0.8 - (red)
                    '#c0392b',  // 0.9-1.0 - pathogenic (dark red)
                ];

                buckets.forEach((residues, idx) => {
                    if (residues.length === 0) return;

                    const t = idx / 9;  // 0 to 1
                    let color;

                    if (isConstraintStacked) {
                        // Use pathogenicity gradient for constraint stacked tracks
                        // Score 0 = benign (green), Score 1 = pathogenic (red)
                        const colorIdx = isFlipped ? (9 - idx) : idx;
                        color = d3.color(pathogenicityColors[colorIdx]);
                    } else {
                        let colorValue;

                        if (isOE) {
                            // O/E tracks: low O/E = constrained = blue, high O/E = tolerant = red
                            // Normal: blue(0) -> red(1), Flipped: red(0) -> blue(1)
                            colorValue = isFlipped ? (1 - t) : t;
                        } else if (isVIR) {
                            // VIR tracks: reversed (red high, blue low) - same as comparators
                            colorValue = isFlipped ? (1 - t) : t;
                        } else if (isComparator) {
                            // Comparator tracks: red high = pathogenic, blue low = benign
                            colorValue = isFlipped ? (1 - t) : t;
                        } else {
                            // Default constraint: red (0 = constrained) -> blue (1 = tolerant)
                            colorValue = isFlipped ? t : (1 - t);
                        }

                        // Get RGB from d3 scale
                        const colorScale = d3.scaleSequential(d3.interpolateRdYlBu).domain([0, 1]);
                        color = d3.color(colorScale(colorValue));
                    }

                    colorSelections.push({
                        residues: residues,
                        color: { r: color.r, g: color.g, b: color.b }
                    });
                });

                // Apply colors using PDBe Molstar visual.select API
                // Build selection data with per-residue colors
                const selectionData = [];

                colorSelections.forEach(sel => {
                    sel.residues.forEach(residue => {
                        selectionData.push({
                            start_residue_number: residue,
                            end_residue_number: residue,
                            color: {
                                r: Math.round(sel.color.r),
                                g: Math.round(sel.color.g),
                                b: Math.round(sel.color.b)
                            },
                            focus: false
                        });
                    });
                });

                // Note: This is legacy PDBe code - visual.select is not available in bare plugin
                // The main applyResidueColoring now uses applyResidueColoringMolstarNative
                console.warn('applyResidueColoringPdbe: PDBe visual.select not available');

            } catch (error) {
                console.error('Error in legacy PDBe coloring:', error);
            }
        }

        /**
         * Apply residue coloring using native Mol* APIs
         * This is used when running with direct Mol* viewer instead of PDBe wrapper
         * 
         * Strategy: Create a new cartoon representation with a custom color theme
         * that maps residue auth_seq_id to colors based on the track data.
         */
        async function applyResidueColoringMolstarNative(colorData, trackId, retryCount = 0) {
            const MAX_RETRIES = 10;

            if (!plugin) {
                console.warn('[COLORING] applyResidueColoringMolstarNative: plugin not ready');
                return;
            }

            // Wait until structure hierarchy is ready
            const structs = plugin.managers?.structure?.hierarchy?.current?.structures;
            if (!structs || structs.length === 0) {
                if (retryCount < MAX_RETRIES) {
                    setTimeout(() => applyResidueColoringMolstarNative(colorData, trackId, retryCount + 1), 300);
                }
                return;
            }

            // Build/refresh trackColorMap using the track's color scale
            try {
                const colorScale = getColorScaleForTrack(trackId, false);
                trackColorMap.clear();

                for (const d of colorData) {
                    const css = colorScale(d.score);
                    const hex = d3ColorStringToHex(css);
                    // NOTE: We key by label_seq_id; for AlphaFold this matches residue numbering.
                    trackColorMap.set(d.residue, hex);
                }

                // Debug: show sample of trackColorMap entries
                const sampleKeys = Array.from(trackColorMap.keys()).slice(0, 5);
                const sampleEntries = sampleKeys.map(k => `${k}:0x${trackColorMap.get(k).toString(16)}`);
                console.log(`[COLORING] trackColorMap built: ${trackColorMap.size} entries, samples: [${sampleEntries.join(', ')}]`);

                await applyTrackTheme(plugin);

                // Cache
                lastAppliedColorData = colorData;
                lastAppliedTrackId = trackId;

                updateStatus(`Colored ${trackColorMap.size} residues`);
            } catch (e) {
                console.warn('[COLORING] Failed to apply track theme:', e.message);
            }
        }


        function buildResidueLoci(plugin, structureData, residueNumbers) {
            try {
                if (!structureData || !residueNumbers?.length) return null;
                
                const StructureElement = molstar?.StructureElement;
                const StructureSelection = molstar?.StructureSelection;
                const Script = molstar?.Script;
                
                // Try to build using Script if available
                if (Script?.struct?.generator?.atomGroups) {
                    // Build a query for these residues
                    const residueSet = new Set(residueNumbers);
                    
                    // Create expression to select by auth_seq_id
                    const expression = Script.struct.generator.atomGroups({
                        'residue-test': Script.struct.filter.pick({
                            '0': Script.struct.generator.atomGroups({
                                'residue-test': Script.struct.type.set(residueNumbers)
                            }),
                            'test': Script.struct.type.boolean(true)
                        })
                    });
                    
                    // This is complex - fall back to simpler approach
                }
                
                // Simpler approach: iterate through structure and build loci manually
                if (StructureElement?.Loci) {
                    const residueSet = new Set(residueNumbers);
                    const elements = [];
                    
                    // Get all units in the structure
                    const units = structureData.units;
                    if (!units) return null;
                    
                    for (let i = 0; i < units.length; i++) {
                        const unit = units[i];
                        const residueIndex = unit.model?.atomicHierarchy?.residueAtomSegments;
                        const authSeqId = unit.model?.atomicHierarchy?.residues?.auth_seq_id;
                        
                        if (!residueIndex || !authSeqId) continue;
                        
                        // Find atoms belonging to our target residues
                        const indices = [];
                        const elementCount = unit.elements.length;
                        
                        for (let j = 0; j < elementCount; j++) {
                            const atomIndex = unit.elements[j];
                            // Find which residue this atom belongs to
                            let residueIdx = 0;
                            for (let k = 0; k < residueIndex.count; k++) {
                                if (atomIndex >= residueIndex.offsets[k] && atomIndex < residueIndex.offsets[k + 1]) {
                                    residueIdx = k;
                                    break;
                                }
                            }
                            
                            const seqId = authSeqId.value(residueIdx);
                            if (residueSet.has(seqId)) {
                                indices.push(j);
                            }
                        }
                        
                        if (indices.length > 0) {
                            // Create SortedArray from indices
                            const SortedArray = unit.elements.constructor;
                            if (SortedArray?.ofSortedArray) {
                                elements.push({
                                    unit,
                                    indices: SortedArray.ofSortedArray(new Int32Array(indices.sort((a, b) => a - b)))
                                });
                            }
                        }
                    }
                    
                    if (elements.length > 0) {
                        return StructureElement.Loci(structureData, elements);
                    }
                }
                
                return null;
            } catch (e) {
                return null;
            }
        }

        // Flag to log tooltip API warning only once
        let tooltipApiWarningLogged = false;

        // Apply custom tooltips - using bare plugin, we rely on custom HTML tooltips
        // The PDBe visual.tooltips() API is not available in bare plugin mode
        function applyCustomTooltips(colorData, trackId) {
            // Custom HTML tooltip is handled by setupCanvasHoverEvents
            // No action needed here for bare plugin
            return;
        }

        function highlightResiduesByScore(colorData) {
            // Legacy function - now calls applyResidueColoring
            applyResidueColoring(colorData, 'legacy');
        }
        
        async function highlightGenomicPositions(residueNum) {
            if (!currentStructureGene) return;
            
            try {
                // Get genomic positions for this residue
                const response = await fetch(
                    `${API_BASE}/api/protein/${currentStructureGene}/coordinate-map?residue=${residueNum}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Find the filtered indices for these positions
                    const positions = data.genomic_positions || [];
                    
                    // Highlight in the track viewer
                    // This will be implemented when we have the sync working
                }
            } catch (error) { /* ignore */ }
        }
        
        async function navigateToResidue(residueNum) {
            if (!currentStructureGene) return;
            
            try {
                // Get genomic positions for this residue
                const response = await fetch(
                    `${API_BASE}/api/protein/${currentStructureGene}/coordinate-map?residue=${residueNum}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const positions = data.genomic_positions || [];
                    
                    if (positions.length > 0) {
                        // Find the filtered index for the first position
                        const pos = positions[0];
                        
                        // Search for this position in our data
                        const searchResponse = await fetch(
                            `${API_BASE}/api/search/position?chrom=${pos.chrom}&pos=${pos.pos}&filter_id=${currentFilter}`
                        );
                        
                        if (searchResponse.ok) {
                            const searchData = await searchResponse.json();
                            if (searchData.result && searchData.result.filtered_idx !== undefined) {
                                // Navigate to this position
                                const idx = searchData.result.filtered_idx;
                                const windowSize = currentRange[1] - currentRange[0];
                                const newStart = Math.max(0, idx - Math.floor(windowSize / 2));
                                const newEnd = newStart + windowSize;
                                
                                currentRange = [newStart, newEnd];
                                document.getElementById('start-input').value = newStart;
                                document.getElementById('end-input').value = newEnd;
                                
                                await loadData();
                                updateStatus(`Navigated to residue ${residueNum} (${pos.chrom}:${pos.pos})`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error navigating to residue:', error);
            }
        }

        // Move crosshair and show highlight for a protein residue
        // Called when clicking residues in 3D structure
        async function moveCrosshairToResidue(residueNum) {
            if (!currentStructureGene) return;

            // Ensure we have the track scale available
            if (!trackXScale || trackPlotWidth === null) {
                if (DEBUG_RESIDUE_MAPPING) {
                    console.log(`[DEBUG] moveCrosshairToResidue: trackXScale or trackPlotWidth not set`);
                }
                return;
            }

            try {
                // Use gene-aa-lookup to get all positions for this residue directly
                // The API expects 1-indexed residue numbers (matching protein sequence)
                const url = `${API_BASE}/api/gene-aa-lookup?filter_id=${currentFilter}&gene=${currentStructureGene}&aa_start=${residueNum}&aa_end=${residueNum}`;

                if (DEBUG_RESIDUE_MAPPING) {
                    console.log(`[DEBUG] moveCrosshairToResidue: residueNum=${residueNum}, url=${url}`);
                }

                const response = await fetch(url);

                if (response.ok) {
                    const data = await response.json();

                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log(`[DEBUG] API response:`, {
                            aa_start: data.aa_start,
                            aa_end: data.aa_end,
                            compressed_start: data.compressed_start,
                            compressed_end: data.compressed_end,
                            genomic_start: data.genomic_start,
                            genomic_end: data.genomic_end,
                            chrom: data.chrom
                        });
                    }

                    // Get the highlight rect and crosshair from the crosshair-layer
                    // Note: these elements are inside the translated 'g' group, so coordinates
                    // are relative to the plot area (not including margins)
                    const highlightRect = d3.select('.crosshair-layer rect');
                    const crosshairLine = d3.select('.crosshair-layer line');

                    if (!highlightRect.empty()) {
                        // Use the globally stored trackXScale (same scale used for rendering tracks)
                        // Apply the current zoom transform to get the current visible scale
                        const xScaleCurrent = currentZoomTransform.rescaleX(trackXScale);

                        // Get the range of positions for this residue
                        // compressed_start and compressed_end are the filtered_idx values
                        const startIdx = data.compressed_start;
                        const endIdx = data.compressed_end;

                        // Get the actual current plot width from the SVG if available
                        // This ensures we use the most up-to-date width after any resizes
                        let currentPlotWidth = trackPlotWidth;
                        const svg = d3.select('#overlay-svg');
                        if (!svg.empty()) {
                            const svgWidth = parseFloat(svg.attr('width')) || 0;
                            if (svgWidth > 0) {
                                currentPlotWidth = svgWidth - MARGIN.left - MARGIN.right;
                            }
                        }

                        if (DEBUG_RESIDUE_MAPPING) {
                            console.log(`[DEBUG] Highlighting compressed indices: ${startIdx} to ${endIdx}, plotWidth=${currentPlotWidth}`);
                        }

                        // Convert indices to pixel coordinates
                        const x1 = xScaleCurrent(startIdx);
                        const x2 = xScaleCurrent(endIdx);

                        // Calculate width of one index unit (for minimum width calculation)
                        const oneUnitWidth = Math.abs(xScaleCurrent(startIdx + 1) - xScaleCurrent(startIdx));

                        // Check if at least part of the region is in view
                        // Use currentPlotWidth (the actual plot area width, not including margins)
                        if (x2 >= 0 && x1 <= currentPlotWidth) {
                            // Clamp to visible area (0 to currentPlotWidth)
                            const visibleX1 = Math.max(0, Math.min(x1, currentPlotWidth));
                            const visibleX2 = Math.max(0, Math.min(x2, currentPlotWidth));
                            // Width should be at least 3px or the width of one index
                            const rawWidth = visibleX2 - visibleX1 + oneUnitWidth;
                            // Clamp width to not exceed plot bounds
                            const rectWidth = Math.max(3, Math.min(rawWidth, currentPlotWidth - visibleX1));

                            // Show highlight rect (strictly clipped to plot area)
                            highlightRect
                                .attr('x', visibleX1)
                                .attr('width', rectWidth)
                                .attr('opacity', 1);

                            // Move crosshair to center of region (clamped to plot area)
                            const centerX = Math.max(0, Math.min((x1 + x2) / 2, currentPlotWidth));
                            if (!crosshairLine.empty()) {
                                crosshairLine
                                    .attr('x1', centerX)
                                    .attr('x2', centerX)
                                    .attr('opacity', 1);
                            }

                            // Update position info - show the residue number we clicked
                            document.getElementById('position-info').textContent =
                                `${data.chrom}:${data.genomic_start.toLocaleString()}-${data.genomic_end.toLocaleString()} | Residue ${residueNum}`;

                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log(`[DEBUG] Highlight applied: x=${visibleX1}, width=${rectWidth}, residue=${residueNum}`);
                            }
                        } else if (DEBUG_RESIDUE_MAPPING) {
                            console.log(`[DEBUG] Residue ${residueNum} not in visible range (x1=${x1}, x2=${x2}, plotWidth=${currentPlotWidth})`);
                        }
                    }
                } else if (DEBUG_RESIDUE_MAPPING) {
                    console.log(`[DEBUG] API request failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                if (DEBUG_RESIDUE_MAPPING) {
                    console.log(`[DEBUG] moveCrosshairToResidue error:`, error);
                }
                // Silently ignore - residue may not be in current filter
            }
        }

        // Clear residue highlight (called when mouse leaves 3D structure)
        function clearResidueHighlight() {
            const highlightRect = d3.select('.crosshair-layer rect');
            const crosshairLine = d3.select('.crosshair-layer line');
            if (!highlightRect.empty()) {
                highlightRect.attr('opacity', 0);
            }
            if (!crosshairLine.empty()) {
                crosshairLine.attr('opacity', 0);
            }
        }

        function updateDomainLegend(domains) {
            const container = document.getElementById('domain-legend-items');
            container.innerHTML = '';
            
            if (!domains || domains.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 0.7rem;">No domains</div>';
                return;
            }
            
            // Group by unique domain names
            const uniqueDomains = [];
            const seen = new Set();
            
            for (const domain of domains) {
                const key = domain.interpro_id || domain.name;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueDomains.push(domain);
                }
            }
            
            // Create legend items
            uniqueDomains.slice(0, 8).forEach((domain, i) => {
                const item = document.createElement('div');
                item.className = 'domain-legend-item';
                item.innerHTML = `
                    <div class="domain-legend-color" style="background: ${DOMAIN_COLORS[i % DOMAIN_COLORS.length]}"></div>
                    <span title="${domain.name}">${domain.name.substring(0, 30)}${domain.name.length > 30 ? '...' : ''}</span>
                    <span style="color: #666;">(${domain.start}-${domain.end})</span>
                `;
                container.appendChild(item);
            });
            
            if (uniqueDomains.length > 8) {
                const more = document.createElement('div');
                more.style.cssText = 'color: #666; font-size: 0.65rem; margin-top: 4px;';
                more.textContent = `+${uniqueDomains.length - 8} more domains`;
                container.appendChild(more);
            }
        }
        
        // Function to highlight a residue in Mol* from track viewer
        // Uses direct Mol* loci highlight API (not PDBe visual.highlight)
        function highlightResidueInStructure(residueNum) {
            if (!plugin) return;

            try {
                // Clear previous highlight first
                if (plugin.managers?.interactivity?.lociHighlights) {
                    plugin.managers.interactivity.lociHighlights.clearHighlights();
                }

                // For direct Mol*, we need to construct a loci for the residue
                // This is complex without the PDBe wrapper, so we use a simpler approach:
                // Just clear any existing highlight - the click handler will create the halo
                if (DEBUG_RESIDUE_MAPPING) {
                    console.log(`[DEBUG] highlightResidueInStructure: residue ${residueNum} (direct Mol* mode)`);
                }
            } catch (error) {
                if (DEBUG_RESIDUE_MAPPING) {
                    console.log('[DEBUG] highlightResidueInStructure error:', error.message);
                }
            }
        }

        // Function to clear highlight from structure (uses direct Mol* APIs)
        function clearStructureHighlight() {
            if (!plugin) return;
            
            try {
                if (plugin.managers?.interactivity?.lociHighlights) {
                    plugin.managers.interactivity.lociHighlights.clearHighlights();
                }
            } catch (e) {
                // Ignore errors
            }
        }

        // Set up hover tracking to sync crosshair with 3D view and show custom tooltip
        function setupCanvasHoverEvents() {
            if (!plugin) {
                setTimeout(setupCanvasHoverEvents, 1000);
                return;
            }
            const tooltip = document.getElementById('structure-tooltip');
            const viewerContainer = document.querySelector('.structure-viewer-container');
            let lastHoveredResidue = null;
            let lastMouseX = 0;
            let lastMouseY = 0;

            // Track mouse position within the viewer for cursor-following tooltip
            const viewerEl = document.getElementById('molstar-viewer');
            if (viewerEl) {
                viewerEl.addEventListener('mousemove', (event) => {
                    // Get position relative to the structure-viewer-container
                    if (viewerContainer) {
                        const rect = viewerContainer.getBoundingClientRect();
                        lastMouseX = event.clientX - rect.left;
                        lastMouseY = event.clientY - rect.top;
                        // Update tooltip position if visible
                        if (tooltip && tooltip.classList.contains('visible')) {
                            positionTooltipNearCursor(lastMouseX, lastMouseY);
                        }
                    }
                });
            }

            // Position tooltip near cursor, clamped within container bounds
            function positionTooltipNearCursor(mouseX, mouseY) {
                if (!tooltip || !viewerContainer) return;

                const containerRect = viewerContainer.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width || 150;  // fallback if not rendered
                const tooltipHeight = tooltipRect.height || 50;

                // Offset from cursor
                const offsetX = 15;
                const offsetY = 15;

                // Calculate position (prefer bottom-right of cursor)
                let left = mouseX + offsetX;
                let top = mouseY + offsetY;

                // Clamp to stay within container
                // Right edge
                if (left + tooltipWidth > containerRect.width - 10) {
                    left = mouseX - tooltipWidth - offsetX;  // flip to left of cursor
                }
                // Left edge
                if (left < 10) {
                    left = 10;
                }
                // Bottom edge (also account for any controls at bottom)
                if (top + tooltipHeight > containerRect.height - 10) {
                    top = mouseY - tooltipHeight - offsetY;  // flip to above cursor
                }
                // Top edge
                if (top < 10) {
                    top = 10;
                }

                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
            }

            // Helper to show custom tooltip
            function showStructureTooltip(residue) {
                if (!tooltip) return;

                // Build tooltip content
                let content = `<span class="tooltip-residue">Residue: ${residue}</span>`;

                // Look up score from lastAppliedColorData if available
                if (lastAppliedColorData && lastAppliedColorData.length > 0) {
                    const dataPoint = lastAppliedColorData.find(d => d.residue === residue);
                    if (dataPoint) {
                        const scoreValue = dataPoint.rawScore !== undefined ? dataPoint.rawScore : dataPoint.score;
                        const displayScore = typeof scoreValue === 'number' ? scoreValue.toFixed(3) : scoreValue;

                        content += `<span class="tooltip-score">Value: <span class="tooltip-score-value">${displayScore}</span></span>`;
                    }
                }

                tooltip.innerHTML = content;
                tooltip.classList.add('visible');
                // Position near cursor
                positionTooltipNearCursor(lastMouseX, lastMouseY);
            }

            // Helper to hide custom tooltip
            function hideStructureTooltip() {
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
                // Note: We don't clear the track highlight here anymore
                // since we switched to click-based highlighting that should persist
            }

            // Helper to decode Mol* packed Interval (two 32-bit ints packed into a 64-bit float)
            // The interval stores [min, max) where min is in the lower 32 bits
            function decodeInterval(packedFloat) {
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                view.setFloat64(0, packedFloat, true); // little-endian
                const min = view.getInt32(0, true);
                const max = view.getInt32(4, true);
                return { min, max };
            }

            // Helper to extract residue info from loci (returns both label_seq_id and auth_seq_id)
            function getResidueFromLoci(loci) {
                if (!loci || loci.kind !== 'element-loci' || !loci.elements?.length) {
                    return null;
                }

                try {
                    const element = loci.elements[0];
                    const unit = element.unit;

                    if (!unit || !unit.model) return null;

                    let elementIndexInUnit;

                    // element.indices is a packed Interval (number) in Mol*
                    if (typeof element.indices === 'number') {
                        const interval = decodeInterval(element.indices);
                        elementIndexInUnit = interval.min;
                    } else if (element.indices && typeof element.indices.min === 'number') {
                        elementIndexInUnit = element.indices.min;
                    } else if (element.indices && element.indices[0] !== undefined) {
                        elementIndexInUnit = element.indices[0];
                    } else {
                        elementIndexInUnit = 0;
                    }

                    const atomIndex = unit.elements[elementIndexInUnit];
                    if (atomIndex === undefined) return null;

                    const residueIndex = unit.residueIndex[atomIndex];
                    if (residueIndex === undefined || !unit.model.atomicHierarchy?.residues) return null;

                    const residues = unit.model.atomicHierarchy.residues;
                    const labelSeqId = residues.label_seq_id?.value(residueIndex);
                    const authSeqId = residues.auth_seq_id?.value(residueIndex);

                    // For AlphaFold structures, label_seq_id typically matches the protein sequence (1-indexed)
                    // auth_seq_id may differ in some PDB files but is usually the same for AlphaFold
                    // We use label_seq_id as it directly corresponds to the protein residue number
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log(`[DEBUG] Residue from loci: label_seq_id=${labelSeqId}, auth_seq_id=${authSeqId}`);
                    }

                    return labelSeqId;
                } catch (e) {
                    return null;
                }
            }

            // Helper to extract residue centroid (center position) from loci
            // Returns {x, y, z} or null if not available
            function getResidueCentroidFromLoci(loci) {
                if (!loci || loci.kind !== 'element-loci' || !loci.elements?.length) {
                    return null;
                }

                try {
                    const element = loci.elements[0];
                    const unit = element.unit;

                    if (!unit || !unit.model || !unit.conformation) return null;

                    // Get the atom indices for this element
                    let startIdx, endIdx;
                    if (typeof element.indices === 'number') {
                        const interval = decodeInterval(element.indices);
                        startIdx = interval.min;
                        endIdx = interval.max;
                    } else if (element.indices && typeof element.indices.min === 'number') {
                        startIdx = element.indices.min;
                        endIdx = element.indices.max || startIdx + 1;
                    } else {
                        startIdx = 0;
                        endIdx = 1;
                    }

                    // Compute centroid of all atoms in this residue selection
                    let sumX = 0, sumY = 0, sumZ = 0;
                    let count = 0;

                    const { x, y, z } = unit.conformation.coordinates;

                    for (let i = startIdx; i < endIdx; i++) {
                        const atomIdx = unit.elements[i];
                        if (atomIdx !== undefined) {
                            sumX += x[atomIdx];
                            sumY += y[atomIdx];
                            sumZ += z[atomIdx];
                            count++;
                        }
                    }

                    if (count === 0) return null;

                    return {
                        x: sumX / count,
                        y: sumY / count,
                        z: sumZ / count
                    };
                } catch (e) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] Could not get residue centroid:', e.message);
                    }
                    return null;
                }
            }

            // ============================================================
            // True Sphere Halo Implementation using Mol* Shape/MeshBuilder
            // ============================================================
            // Creates a semi-transparent yellow sphere around clicked residues
            // using Mol*'s MeshBuilder API for a true geometric sphere.
            // This requires direct Mol* (not PDBe wrapper) for Shape API access.
            // ============================================================

            // Tag for identifying our sphere in the state tree
            const SPHERE_HALO_TAG = 'residue-highlight-sphere';

            // Global ref for the sphere state node
            let sphereHaloRef = null;

            /**
             * Remove existing sphere halo from the state tree
             */
            async function removeHalo() {
                if (!plugin) {
                    sphereHaloRef = null;
                    return;
                }

                try {
                    const state = plugin.state.data;

                    // Method 1: Delete by stored ref (for state tree components)
                    if (sphereHaloRef && !sphereHaloRef.startsWith?.('component-')) {
                        try {
                            const cell = state.cells.get(sphereHaloRef);
                            if (cell) {
                                await plugin.build().delete(sphereHaloRef).commit();
                                if (DEBUG_RESIDUE_MAPPING) {
                                    console.log('[DEBUG] Sphere halo removed by ref:', sphereHaloRef);
                                }
                            }
                        } catch (e) {
                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log('[DEBUG] Could not remove sphere by ref:', e.message);
                            }
                        }
                    }

                    // Method 2: Find by tag and delete (most reliable for state tree nodes)
                    try {
                        const toDelete = [];
                        state.cells.forEach((cell, ref) => {
                            if (cell.transform?.tags?.includes(SPHERE_HALO_TAG)) {
                                toDelete.push(ref);
                            }
                        });

                        if (toDelete.length > 0) {
                            const update = plugin.build();
                            for (const ref of toDelete) {
                                update.delete(ref);
                            }
                            await update.commit();
                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log('[DEBUG] Removed', toDelete.length, 'sphere halo(s) by tag');
                            }
                        }
                    } catch (e) {
                        // Tag-based deletion is optional
                    }

                    // Method 4: Clear structure selection (if we used that method)
                    try {
                        if (plugin.managers?.structure?.selection) {
                            plugin.managers.structure.selection.clear();
                        }
                    } catch (e) {
                        // Ignore
                    }

                    sphereHaloRef = null;

                } catch (e) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] Error in removeHalo:', e.message);
                    }
                    sphereHaloRef = null;
                }
            }

            /**
             * Extract a single-atom loci (CA preferred, or first atom fallback) from a residue loci.
             * This is the core fix: we iterate through the loci's elements and indices,
             * find the CA atom (or first atom), and construct a new StructureElement.Loci
             * containing ONLY that single atom.
             *
             * CRITICAL: The indices must be a proper Mol* SortedArray/OrderedSet, not a plain number.
             * We access the SortedArray.ofSingleton factory from the existing indices object's constructor.
             *
             * @param {Object} plugin - The Mol* plugin instance
             * @param {Object} residueLoci - The original residue loci from click event
             * @returns {Object} A new loci containing only the central atom, or the original if extraction fails
             */
            function extractCentralAtomLoci(plugin, residueLoci) {
                if (!residueLoci || !residueLoci.elements?.length) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] extractCentralAtomLoci: invalid or empty loci');
                    }
                    return residueLoci;
                }

                try {
                    // Iterate through all elements in the loci
                    for (const e of residueLoci.elements) {
                        const unit = e.unit;
                        if (!unit?.model) continue;

                        const { atomicHierarchy } = unit.model;
                        const { label_atom_id } = atomicHierarchy.atoms;
                        const originalIndices = e.indices;

                        // The indices in Mol* are typically a SortedArray (Int32Array subclass)
                        // We need to extract individual values from it
                        let indicesArray = [];

                        // SortedArray is array-like with a length property
                        if (originalIndices && typeof originalIndices.length === 'number') {
                            for (let i = 0; i < originalIndices.length; i++) {
                                indicesArray.push(originalIndices[i]);
                            }
                        } else if (typeof originalIndices === 'number') {
                            // Encoded interval format (legacy)
                            const decoded = decodeInterval(originalIndices);
                            for (let i = decoded.min; i < decoded.max; i++) {
                                indicesArray.push(i);
                            }
                        } else {
                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log('[DEBUG] extractCentralAtomLoci: cannot iterate indices, type:', typeof originalIndices);
                            }
                            continue;
                        }

                        if (indicesArray.length === 0) continue;

                        // Search for CA atom first
                        let caIdx = null;
                        let c4PrimeIdx = null;
                        let firstIdx = indicesArray[0];

                        for (const idx of indicesArray) {
                            const atomIdx = unit.elements[idx];
                            if (atomIdx === undefined) continue;

                            const atomName = label_atom_id.value(atomIdx);

                            if (atomName === 'CA') {
                                caIdx = idx;
                                break; // Found CA, stop searching
                            }
                            if (atomName === "C4'" && c4PrimeIdx === null) {
                                c4PrimeIdx = idx; // Store C4' as backup for nucleic acids
                            }
                        }

                        // Determine which atom to use
                        const targetIdx = caIdx !== null ? caIdx : (c4PrimeIdx !== null ? c4PrimeIdx : firstIdx);
                        const targetAtomIdx = unit.elements[targetIdx];
                        const targetAtomName = label_atom_id.value(targetAtomIdx);

                        if (DEBUG_RESIDUE_MAPPING) {
                            console.log(`[DEBUG] extractCentralAtomLoci: selected atom ${targetAtomName} at element index ${targetIdx} (CA found: ${caIdx !== null})`);
                        }

                        // Create a proper SortedArray with single element
                        // The key insight: SortedArray is essentially an Int32Array
                        // We can create one using the same constructor pattern
                        let singleAtomIndices;

                        // Try to get SortedArray.ofSingleton from Mol* internals
                        // Strategy 1: Check if there's a static ofSingleton on the indices constructor
                        const IndicesConstructor = originalIndices?.constructor;
                        if (IndicesConstructor?.ofSingleton) {
                            singleAtomIndices = IndicesConstructor.ofSingleton(targetIdx);
                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log('[DEBUG] extractCentralAtomLoci: used constructor.ofSingleton');
                            }
                        }
                        // Strategy 2: Create Int32Array directly (SortedArray is Int32Array based)
                        else {
                            singleAtomIndices = new Int32Array([targetIdx]);
                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log('[DEBUG] extractCentralAtomLoci: created Int32Array for single atom');
                            }
                        }

                        // Construct the new single-atom loci
                        // IMPORTANT: Use the SAME structure reference from the original loci
                        const singleAtomLoci = {
                            kind: 'element-loci',
                            structure: residueLoci.structure,  // Same structure reference
                            elements: [{
                                unit: unit,  // Same unit reference
                                indices: singleAtomIndices
                            }]
                        };

                        if (DEBUG_RESIDUE_MAPPING) {
                            console.log('[DEBUG] extractCentralAtomLoci: created single-atom loci with indices:', singleAtomIndices);
                        }

                        return singleAtomLoci;
                    }

                    // If we couldn't extract, return original
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] extractCentralAtomLoci: could not extract single atom, returning original loci');
                    }
                    return residueLoci;

                } catch (err) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] extractCentralAtomLoci error:', err.message);
                        console.log('[DEBUG] extractCentralAtomLoci stack:', err.stack);
                    }
                    return residueLoci;
                }
            }

            /**
             * Legacy helper - now wraps extractCentralAtomLoci for compatibility
             * @deprecated Use extractCentralAtomLoci instead
             */
            function findCentralAtomFromLoci(loci) {
                // This is now just for backward compatibility with debug logging
                if (!loci || loci.kind !== 'element-loci' || !loci.elements?.length) {
                    return null;
                }

                try {
                    const element = loci.elements[0];
                    const unit = element.unit;
                    if (!unit?.model) return null;

                    const { atomicHierarchy } = unit.model;
                    const { label_atom_id } = atomicHierarchy.atoms;

                    // Decode the element indices
                    let startIdx, endIdx;
                    if (typeof element.indices === 'number') {
                        const decoded = decodeInterval(element.indices);
                        startIdx = decoded.min;
                        endIdx = decoded.max;
                    } else if (element.indices?.min !== undefined) {
                        startIdx = element.indices.min;
                        endIdx = element.indices.max || startIdx + 1;
                    } else {
                        return null;
                    }

                    // Search for CA atom
                    let caIndex = null;
                    let firstAtomIndex = null;
                    let foundAtomName = null;

                    for (let i = startIdx; i < endIdx; i++) {
                        const atomIdx = unit.elements[i];
                        if (atomIdx === undefined) continue;

                        if (firstAtomIndex === null) {
                            firstAtomIndex = i;
                        }

                        const atomName = label_atom_id.value(atomIdx);
                        if (atomName === 'CA') {
                            caIndex = i;
                            foundAtomName = 'CA';
                            break;
                        }
                        if (atomName === "C4'" && caIndex === null) {
                            caIndex = i;
                            foundAtomName = "C4'";
                        }
                    }

                    const resultIndex = caIndex !== null ? caIndex : firstAtomIndex;
                    if (resultIndex === null) return null;

                    return {
                        unitIndex: 0,
                        atomIndex: resultIndex,
                        atomName: foundAtomName || 'first',
                        found: caIndex !== null
                    };
                } catch (e) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] Error finding central atom:', e.message);
                    }
                    return null;
                }
            }

            /**
             * Create a sphere halo around the clicked residue using single-atom spacefill
             * This approach creates a large spacefill representation on just the CA atom
             * to create a "halo sphere" effect.
             *
             * @param {Object} loci - The Mol* loci from click event
             * @param {number} residueNum - The residue number for logging
             * @param {number} sizeFactor - Size factor for spacefill (default 3.0)
             * @param {number} alpha - Transparency 0-1 (default 0.4)
             */
            async function createSphereHalo(loci, residueNum, sizeFactor = 10.0, alpha = 0.4) {
                console.log('[HALO] createSphereHalo called, loci:', loci, 'residueNum:', residueNum);

                if (!loci || loci.elements?.length === 0) {
                    console.warn('[HALO] empty loci, abort halo');
                    return false;
                }

                if (!plugin) {
                    console.warn('[HALO] plugin not available');
                    return false;
                }

                try {
                    // 1. Remove existing halo first
                    console.log('[HALO] removing existing halo');
                    await removeHalo();

                    // 2. Extract single-atom loci (CA preferred, fallback to first atom)
                    console.log('[HALO] extracting central atom loci');
                    const singleAtomLoci = extractCentralAtomLoci(plugin, loci);
                    if (!singleAtomLoci || !singleAtomLoci.elements?.length) {
                        console.warn('[HALO] could not extract single-atom loci');
                        return false;
                    }
                    console.log('[HALO] singleAtomLoci:', singleAtomLoci);

                    // 3. Get the structure from the loci
                    const structure = singleAtomLoci.structure;
                    if (!structure) {
                        console.warn('[HALO] no structure in loci');
                        return false;
                    }
                    console.log('[HALO] structure found');

                    // 4. Find the structure cell in the state tree
                    let structureRef = null;
                    plugin.state.data.cells.forEach((cell, ref) => {
                        if (cell.obj?.data === structure) {
                            structureRef = ref;
                        }
                    });

                    if (!structureRef) {
                        console.warn('[HALO] could not find structure in state tree');
                        return false;
                    }
                    console.log('[HALO] structureRef:', structureRef);

                    // 5. Create spacefill halo using StructureElement.Bundle
                    // These APIs are now imported from the ES module
                    const Bundle = StructureElement?.Bundle;

                    console.log('[HALO] StateTransforms:', StateTransforms);
                    console.log('[HALO] StructureElement:', StructureElement);
                    console.log('[HALO] Bundle:', Bundle);

                    // Yellow halo color as hex
                    const HALO_COLOR = 0xFFE632;

                    if (Bundle?.fromLoci && StateTransforms?.Model?.StructureSelectionFromBundle) {
                        console.log('[HALO] building selection from loci via Bundle');
                        const bundle = Bundle.fromLoci(singleAtomLoci);
                        console.log('[HALO] bundle created:', bundle);

                        // Build representation params with transparency
                        // Note: For spacefill, sizeFactor multiplies the van der Waals radius
                        // CA atom vdW radius ~1.7Å, so sizeFactor=2.0 gives ~3.4Å radius sphere
                        // sizeTheme must be 'physical' for sizeFactor to work correctly
                        const reprParams = {
                            type: {
                                name: 'spacefill',
                                params: {
                                    sizeFactor: sizeFactor,
                                    alpha: alpha  // Add transparency
                                }
                            },
                            colorTheme: { name: 'uniform', params: { value: HALO_COLOR } },
                            sizeTheme: { name: 'physical' }  // Use physical to respect sizeFactor
                        };
                        console.log('[HALO] reprParams:', reprParams, 'sizeFactor:', sizeFactor);

                        const result = await plugin.build()
                            .to(structureRef)
                            .apply(StateTransforms.Model.StructureSelectionFromBundle, {
                                bundle: bundle,
                                label: `Residue ${residueNum} Halo`
                            }, { tags: [SPHERE_HALO_TAG] })
                            .apply(StateTransforms.Representation.StructureRepresentation3D, reprParams, { tags: [SPHERE_HALO_TAG] })
                            .commit();

                        sphereHaloRef = result?.ref || 'spacefill-halo-' + residueNum;
                        console.log('[HALO] SUCCESS via StructureSelectionFromBundle, ref:', sphereHaloRef);
                        return true;
                    }

                    console.warn('[HALO] Bundle API not available - no suitable API found');
                    return false;

                } catch (e) {
                    console.error('[HALO] Failed to create sphere halo:', e.message, e.stack);
                    return false;
                }
            }

            // Alias for backward compatibility - delegates to createSphereHalo
            async function setCentralAtomSpacefillHalo(loci, residueNum, sizeFactor = 200, alpha = 0.4) {
                console.log('[HALO] setCentralAtomSpacefillHalo called, delegating to createSphereHalo');
                return await createSphereHalo(loci, residueNum, sizeFactor, alpha);
            }

            /**
             * Apply focus/zoom to the clicked residue loci
             * Zooms in to distance 60 if currently zoomed out further, keeps current distance if closer.
             * @param {Object} loci - The Mol* loci to focus on
             * @param {{x: number, y: number, z: number}|null} centroid - Residue centroid position
             */
            async function applyGentleFocus(loci, centroid) {
                if (!plugin) return;

                const MAX_ZOOM_DISTANCE = 60; // Zoom in to at least this distance

                try {
                    const camera = plugin.canvas3d?.camera;
                    if (!camera || !plugin.canvas3d?.requestCameraReset) return;

                    const state = camera.state;

                    // Calculate current camera direction and distance
                    const dx = state.position[0] - state.target[0];
                    const dy = state.position[1] - state.target[1];
                    const dz = state.position[2] - state.target[2];
                    const currentDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    // Normalize direction vector
                    const dirX = dx / currentDistance;
                    const dirY = dy / currentDistance;
                    const dirZ = dz / currentDistance;

                    // Get the new target position (where to pan to)
                    let targetPos = centroid;
                    if (!targetPos && loci) {
                        try {
                            const boundary = plugin.helpers?.structureSelectionManager?.getBoundary?.(loci);
                            if (boundary?.sphere?.center) {
                                const c = boundary.sphere.center;
                                targetPos = { x: c[0], y: c[1], z: c[2] };
                            }
                        } catch (e) { /* ignore */ }
                    }

                    if (!targetPos) {
                        if (DEBUG_RESIDUE_MAPPING) {
                            console.log('[DEBUG] applyGentleFocus: no target position');
                        }
                        return;
                    }

                    // Convert to array
                    const newTarget = [
                        targetPos.x !== undefined ? targetPos.x : targetPos[0],
                        targetPos.y !== undefined ? targetPos.y : targetPos[1],
                        targetPos.z !== undefined ? targetPos.z : targetPos[2]
                    ];

                    // Keep current distance if closer than MAX_ZOOM_DISTANCE, otherwise zoom in to MAX_ZOOM_DISTANCE
                    const targetDistance = Math.min(currentDistance, MAX_ZOOM_DISTANCE);

                    // Calculate new position: target distance from new target, same direction
                    const newPosition = [
                        newTarget[0] + dirX * targetDistance,
                        newTarget[1] + dirY * targetDistance,
                        newTarget[2] + dirZ * targetDistance
                    ];

                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] applyGentleFocus: panning to', newTarget, 'currentDistance=', currentDistance, 'targetDistance=', targetDistance);
                    }

                    // Use requestCameraReset to set both position and target
                    plugin.canvas3d.requestCameraReset({
                        snapshot: {
                            ...state,
                            target: newTarget,
                            position: newPosition
                        },
                        durationMs: 300
                    });

                } catch (e) {
                    if (DEBUG_RESIDUE_MAPPING) {
                        console.log('[DEBUG] applyGentleFocus error:', e.message);
                    }
                }
            }

            // Helper to clear selection highlight (uses direct Mol* APIs)
            function clearSelectionHighlight() {
                if (!plugin) return;
                
                try {
                    // Clear loci highlights
                    if (plugin.managers?.interactivity?.lociHighlights) {
                        plugin.managers.interactivity.lociHighlights.clearHighlights();
                    }
                    // Clear loci selections
                    if (plugin.managers?.interactivity?.lociSelects) {
                        plugin.managers.interactivity.lociSelects.deselectAll();
                    }
                } catch (e) {
                    // Ignore errors
                }
            }

            // Subscribe to hover behavior - just for tooltip display (lightweight)
            try {
                if (plugin.behaviors?.interaction?.hover) {
                    plugin.behaviors.interaction.hover.subscribe(({ current }) => {
                        const seqId = getResidueFromLoci(current?.loci);
                        if (seqId !== null) {
                            showStructureTooltip(seqId);
                            lastHoveredResidue = seqId;
                        } else {
                            hideStructureTooltip();
                            // Note: We do NOT clear lastHoveredResidue here
                            // because we want click to still work on the last hovered residue
                        }
                    });
                }
            } catch (e) { /* ignore */ }

            /*
             * Click Handler: CA-Centered Halo + Track Sync
             * ---------------------------------------------
             * We subscribe to the plugin's click behavior to get the clicked residue.
             * On click we:
             * 1. Store the selected residue (persists until another click)
             * 2. Create a semi-transparent yellow spacefill halo on CA atom
             * 3. Apply gentle focus/zoom (~40% intensity)
             * 4. Update the track panel crosshair/highlight
             *
             * Note: selectInteraction: false disables ball-and-stick selection on click.
             * The halo uses visual.select with spacefill representation as fallback.
             * lastClickedLoci is now at module scope to allow re-applying halo after color changes.
             */

            try {
                if (plugin.behaviors?.interaction?.click) {
                    plugin.behaviors.interaction.click.subscribe(async (e) => {
                        const { current } = e;
                        const loci = current?.loci;

                        // Debug logging for halo troubleshooting
                        console.log('[HALO] click event:', e);
                        console.log('[HALO] loci kind:', loci?.kind, 'elements:', loci?.elements?.length);

                        const seqId = getResidueFromLoci(loci);
                        if (seqId !== null) {
                            const residueNum = seqId;
                            const centroid = getResidueCentroidFromLoci(loci);

                            // Store as the selected residue (persists until another click)
                            selectedResidue = residueNum;
                            lastClickedLoci = loci;

                            if (DEBUG_RESIDUE_MAPPING) {
                                console.log(`[DEBUG] Click behavior: residueNum=${residueNum}, centroid=`, centroid);
                            }

                            // 1. Create yellow spacefill halo on CA atom (or first atom)
                            // sizeFactor=2.5 creates a moderate semi-transparent sphere halo
                            // (CA vdW radius ~1.7Å × 2.5 = ~4.25Å radius sphere)
                            console.log('[HALO] calling setCentralAtomSpacefillHalo, residueNum:', residueNum);
                            const haloSuccess = await setCentralAtomSpacefillHalo(loci, residueNum, 8, 0.4);
                            console.log('[HALO] haloSuccess:', haloSuccess);

                            // 2. Apply gentler focus/zoom (~40% intensity via extraRadius)
                            await applyGentleFocus(loci, centroid);

                            // 3. Update track panel crosshair/highlight
                            moveCrosshairToResidue(residueNum);
                        } else {
                            // Clicked on empty space - remove the yellow sphere highlight
                            console.log('[HALO] clicked on empty space, removing highlight');
                            await removeHalo();
                            selectedResidue = null;
                            lastClickedLoci = null;
                        }
                    });
                } else {
                    // Fallback to canvas click handler
                    const canvas = document.querySelector('#molstar-viewer canvas');
                    if (canvas) {
                        canvas.addEventListener('click', async (event) => {
                            if (lastHoveredResidue !== null) {
                                const residueNum = lastHoveredResidue;
                                selectedResidue = residueNum;

                                // No loci available for gentle focus in fallback mode
                                await applyGentleFocus(null, null);
                                moveCrosshairToResidue(residueNum);
                            }
                        });
                    }
                }
            } catch (e) { /* ignore */ }

            // Hide tooltip when mouse leaves the viewer (but keep selection highlight)
            if (viewerEl) {
                viewerEl.addEventListener('mouseleave', () => {
                    hideStructureTooltip();
                    // Note: We keep lastHoveredResidue so click still works after mouse leaves
                    // Selection highlight persists (selectedResidue is not cleared here)
                });
            }
        }

        // Function called when hovering over a position in the track viewer
        function onTrackPositionHover(positionData) {
            if (!plugin || !currentStructureGene) return;
            if (!positionData || !positionData.gene_symbol) return;
            
            // Check if this position is in the current structure's gene
            if (positionData.gene_symbol.toUpperCase() !== currentStructureGene) return;
            
            // Get protein residue for this position
            const chrom = positionData.chrom;
            const pos = positionData.pos;
            
            fetch(`${API_BASE}/api/protein/${currentStructureGene}/coordinate-map?chrom=${chrom}&pos=${pos}`)
                .then(response => response.json())
                .then(data => {
                    if (data.mapping && data.mapping.protein_residue) {
                        highlightResidueInStructure(data.mapping.protein_residue);
                    }
                })
                .catch(err => console.error('Error mapping position:', err));
        }
    </script>
</body>
</html>


